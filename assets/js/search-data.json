{
  
    
        "post0": {
            "title": "Folium Test",
            "content": "Folium Test . import folium from IPython.display import HTML, display m = folium.Map(location=[45.5236, -122.6750]) m.save(r&#39;E: Dev DataScienceBlog html test_map.html&#39;) . from IPython.display import Image # display(HTML(r&#39;E: Dev DataScienceBlog html test_map.html&#39;)) Image(filename=r&#39;E: Dev DataScienceBlog png 2021-09-02 19_47_27-Window.png&#39;) .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/ml/visualization/2021/09/01/folium-test.html",
            "relUrl": "/ibm/data_science/ml/visualization/2021/09/01/folium-test.html",
            "date": " • Sep 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Finding a location and type for a restaurant in Los Angeles County, CA",
            "content": "Capstone Project . Finding a location and type for a restaurant in Los Angeles County, CA . . Introduction: Business Problem | Data | Methodology | Analysis | Results and Discussion | Conclusion | . Introduction: Business Problem . In this project I will try to give a recommendation on where to open a restaurant in Los Angeles County, CA. In addition, there shall be given a recommendation of which type of restaurant could be opened, based on existing restaurants in the area and generally popular restaurants in the whole county. . The decision on where to open a restaurant can be based on many factors, depending on the target group. For example, one could look for very dense populated areas, or areas with lots of wealthy citizens. Even the median age of the population can play a role. . I will make a decision based on the following conditions: . Find the area with a good balance between number of possible customers and a high median income (population is slightly more important than income) | the type of restaurant will be determined by the most recommended categories of food venue in Los Angeles County, CA and the number of already existing venues in the area | . Data . I used three different datasets as basis for my analysis. Using these datasets I am able to work with the following features, among others: . A list of areas in Los Angeles County, CA based on the ZIP code | The number of citizens and households in every area | The estimated median income of every area | The latitude and longitude for every zip code in the county | . . I combined the following datasets for this: . 2010 Los Angeles Census Data https://www.kaggle.com/cityofLA/los-angeles-census-data | . | Median Household Income by Zip Code in 2019 http://www.laalmanac.com/employment/em12c.php | . | US Zip Code Latitude and Longitude https://public.opendatasoft.com/explore/dataset/us-zip-code-latitude-and-longitude/information/ | . | . To analyse the existing food venues in the county, the Foursquare API is used. With this API we can provide the data to answer the following two questions: . What are the most recommended types of restaurants in the county? | What are the existing food venues categories in the area where we want to open a restaurant in? | . . Merging the three datasets as basis of the analytics . First, let&#39;s merge all three datasets and get rid of unnecessary information. I will continue to use a single dataframe with the combined datasets as basis for further analysis. . The census data and the geodata for the US zip codes are available as csv files that I will read directly into a dataframe. The records for the median household income are available on a website, so I downloaded the data as a html file, which then is used to create a dataframe. As the median income has a dollar sign and can not be converted into a numeric value automatically because of its format, we have to do some data preparation. . import pandas as pd # Dataset: 2010 Los Angeles Census Data df_census = pd.read_csv(&quot;2010-census-populations-by-zip-code.csv&quot;) # Dataset: Median Household Income by Zip Code in 2019 url = &quot;Median Household Income By Zip Code in Los Angeles County, California.html&quot; dfs = pd.read_html(url) df_income_all = dfs[0] # drop areas where the median income is missing df_income_na = df_income_all[df_income_all[&#39;Estimated Median Income&#39;].notna()] # Next step: clean the values in the median income column to retrieve # numeric values that can be used for clustering / calculation df_income = df_income_na.drop(df_income_na[df_income_na[ &#39;Estimated Median Income&#39;] == &#39;&#39;].index) df_income[&#39;Estimated Median Income&#39;] = df_income[&#39;Estimated Median Income&#39;].map(lambda x: x.lstrip(&#39;$&#39;)) df_income[&#39;Estimated Median Income&#39;] = df_income[&#39;Estimated Median Income&#39;].str.replace(&#39;,&#39;,&#39;&#39;) df_income[&quot;Estimated Median Income&quot;] = pd.to_numeric(df_income[&quot;Estimated Median Income&quot;]) # Dataset: US Zip Code Latitude and Longitude df_geodata = pd.read_csv(&quot;us-zip-code-latitude-and-longitude.csv&quot;, sep=&#39;;&#39;) # Let&#39;s start by joining the geodata on the income dataset via the zip code df_income_geo = df_census.join(df_income.set_index(&#39;Zip Code&#39;), on=&#39;Zip Code&#39;) # Now join the census data with the income dataset and the geodata dataset_geo = df_income_geo.join(df_geodata.set_index(&#39;Zip&#39;), on=&#39;Zip Code&#39;, how=&#39;left&#39;) # Let us only use the columns we need for the further analysis and ignore # the rest prepared_ds = dataset_geo[[ &quot;Zip Code&quot;, &quot;City&quot;, &quot;Community&quot;, &quot;Estimated Median Income&quot;, &quot;Longitude&quot;, &quot;Latitude&quot;, &quot;Total Population&quot;, &quot;Median Age&quot;, &quot;Total Males&quot;, &quot;Total Females&quot;, &quot;Total Households&quot;, &quot;Average Household Size&quot;]] # last stop: let&#39;s drop records with missing data final_ds = prepared_ds.dropna(axis=0) final_ds.shape . (279, 12) . So the final dataframe now contains 279 areas with 12 features. Let&#39;s get an overview on how the records look now: . final_ds.head(5) . Zip Code City Community Estimated Median Income Longitude Latitude Total Population Median Age Total Males Total Females Total Households Average Household Size . 1 90001 | Los Angeles | Los Angeles (South Los Angeles), Florence-Graham | 43360.0 | -118.24878 | 33.972914 | 57110 | 26.6 | 28468 | 28642 | 12971 | 4.40 | . 2 90002 | Los Angeles | Los Angeles (Southeast Los Angeles, Watts) | 37285.0 | -118.24845 | 33.948315 | 51223 | 25.5 | 24876 | 26347 | 11731 | 4.36 | . 3 90003 | Los Angeles | Los Angeles (South Los Angeles, Southeast Los ... | 40598.0 | -118.27600 | 33.962714 | 66266 | 26.3 | 32631 | 33635 | 15642 | 4.22 | . 4 90004 | Los Angeles | Los Angeles (Hancock Park, Rampart Village, Vi... | 49675.0 | -118.30755 | 34.077110 | 62180 | 34.8 | 31302 | 30878 | 22547 | 2.73 | . 5 90005 | Los Angeles | Los Angeles (Hancock Park, Koreatown, Wilshire... | 38491.0 | -118.30848 | 34.058911 | 37681 | 33.9 | 19299 | 18382 | 15044 | 2.50 | . Finding the most recommended food venue categories in the county . Now we will use the Foursquare API to find out what are the most recommended food venues in the county. For this we will go through every single area and get the recommended food venues in the vicinity of the area center. . import foursquare import requests CLIENT_ID = foursquare.CLIENT_ID CLIENT_SECRET = foursquare.CLIENT_SECRET ACCESS_TOKEN = foursquare.ACCESS_TOKEN VERSION = &#39;20210514&#39; # Foursquare API version LIMIT = 100 . areas = final_ds.drop([&#39;Estimated Median Income&#39;, &#39;Total &#39; &#39;Population&#39;, &#39;Median Age&#39;, &#39;Total Males&#39;, &#39;Total Females&#39;, &#39;Total Households&#39;, &#39;Average Household Size&#39;], 1) areas.head() . Zip Code City Community Longitude Latitude . 1 90001 | Los Angeles | Los Angeles (South Los Angeles), Florence-Graham | -118.24878 | 33.972914 | . 2 90002 | Los Angeles | Los Angeles (Southeast Los Angeles, Watts) | -118.24845 | 33.948315 | . 3 90003 | Los Angeles | Los Angeles (South Los Angeles, Southeast Los ... | -118.27600 | 33.962714 | . 4 90004 | Los Angeles | Los Angeles (Hancock Park, Rampart Village, Vi... | -118.30755 | 34.077110 | . 5 90005 | Los Angeles | Los Angeles (Hancock Park, Koreatown, Wilshire... | -118.30848 | 34.058911 | . In the next code block, we will iterate through every area in the dataframe and get up to 50 recommendations per area. For that I use the &quot;explore&quot; endpoint of the Foursquare API. I use the categoryId and sortByPopularity parameters to only request food venues that are sorted by popularity in descending order. . venues_list = [] for index, area in areas.iterrows(): url = &#39;https://api.foursquare&#39; &#39;.com/v2/venues/explore?&amp;client_id={}&amp;client_secret={}&amp;v={}&amp;ll={},&#39; &#39;{}&amp;radius={}&amp;limit={}&amp;offset={}&amp;categoryId={}&amp;sortByPopularity={}&#39; .format( CLIENT_ID, CLIENT_SECRET, VERSION, area[&#39;Latitude&#39;], area[&#39;Longitude&#39;], 1000, LIMIT, 0, &#39;4d4b7105d754a06374d81259&#39;, 1) results = requests.get(url).json()[&quot;response&quot;][&#39;groups&#39;][0][&#39;items&#39;] for v in results: try: # try to extract the city, if there is one in the response city = v[&#39;venue&#39;][&#39;location&#39;][&#39;city&#39;] except: city = area[&#39;City&#39;] try: # try to extract the zip code, if there is one postalCode = str(v[&#39;venue&#39;][&#39;location&#39;][&#39;postalCode&#39;]) except: postalCode = str(area[&#39;Zip Code&#39;]) # build a list with all the columns I want to use if postalCode == str(area[&#39;Zip Code&#39;]): venues_list.append(( area[&#39;Zip Code&#39;], area[&#39;Community&#39;], area[&#39;Latitude&#39;], area[&#39;Longitude&#39;], v[&#39;venue&#39;][&#39;name&#39;], v[&#39;venue&#39;][&#39;categories&#39;][0][&#39;name&#39;], city )) # create a dataframe from the results of the request la_venues = pd.DataFrame(venues_list, columns=[&#39;Zip Code&#39;, &#39;Community&#39;, &#39;Zip Code Latitude&#39;, &#39;Zip Code Longitude&#39;, &#39;Venue&#39;, &#39;Venue Category&#39;, &#39;City&#39;]) . la_venues.head() . Zip Code Community Zip Code Latitude Zip Code Longitude Venue Venue Category City . 0 90001 | Los Angeles (South Los Angeles), Florence-Graham | 33.972914 | -118.24878 | Mi Lindo Nayarit Mariscos | Mexican Restaurant | Los Angeles | . 1 90001 | Los Angeles (South Los Angeles), Florence-Graham | 33.972914 | -118.24878 | Jack in the Box | Fast Food Restaurant | Los Angeles | . 2 90001 | Los Angeles (South Los Angeles), Florence-Graham | 33.972914 | -118.24878 | Mi Lindo Nayarit | Seafood Restaurant | Los Angeles | . 3 90001 | Los Angeles (South Los Angeles), Florence-Graham | 33.972914 | -118.24878 | Birrieria Tlaquepaque | Mexican Restaurant | Los Angeles | . 4 90001 | Los Angeles (South Los Angeles), Florence-Graham | 33.972914 | -118.24878 | Birrieria Jalisco | Mexican Restaurant | Los Angeles | . la_venues[&quot;Venue&quot;].count() . 8603 . So we have found 8,635 recommendations for our 279 areas in Los Angeles County, CA. That are ~31 recommendations per area. Let&#39;s extract the city and venue category and group the data by category, to find out about the distribution of the recommended food venue categories. . venues = la_venues[[&#39;City&#39;, &#39;Venue Category&#39;]] categories = venues.groupby(&#39;Venue Category&#39;).size().to_frame(&#39;Count&#39;).reset_index() sorted = categories.sort_values(by=&#39;Count&#39;, ascending=False) # Sort by Count top10 = sorted.iloc[0:9] # Show the top 10 categories top10 . Venue Category Count . 77 Mexican Restaurant | 814 | . 89 Pizza Place | 574 | . 42 Fast Food Restaurant | 507 | . 24 Chinese Restaurant | 412 | . 99 Sandwich Place | 354 | . 9 Bakery | 347 | . 2 American Restaurant | 300 | . 18 Café | 288 | . 111 Sushi Restaurant | 266 | . After that, we will visualize the distribution. . import plotly.express as px from IPython.display import HTML, display top15 = sorted.iloc[0:14] fig = px.bar(top15, x=&quot;Venue Category&quot;, y=&quot;Count&quot;, title=&#39;Distribution of recommended food venue categories&#39;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . . . So with this data we can tell what food venue categories are recommended the most throughout Los Angeles County, CA. . We have prepared the following data, which we will use for further analysis: . a dataframe with areas in LA County, enriched with geodata, median income and census data | a dataframe with the most recommended food venue categories in the county | . Methodology . In this project we will focus on finding a suitable area for a new restaurant in Los Angeles County, CA. The areas are defined by their US Zip Code. In addition, we will look at the most recommended food venue categories throughout the country, to suggest which type of restaurant could be opened. There won&#39;t be a specific location in the chosen area recommended. . In the first step we have merged three different datasets, that provide data on the different areas in Los Angeles County. With this data it is possible to cluster the areas using information like median income, number of households and number of inhabitants. In addition, using Foursquare, we identified the most recommended food venue categories in the county. . The second step in the analysis is to cluster (using k-means clustering) the areas in the county and to describe the individual clusters. Using this method we support the process of finding a single area that looks promising for a new restaurant. . The third step is to pick a cluster that fits the chosen criteria most. The area shall be chosen under the premise of finding a good balance between estimated median income and number of potential customers. So the target is to find an area that has as many citizens as possible with the highest income possible. After an area was chosen, the distribution of local restaurant types in this area will be analysed. Combining this information with the categories of food venues that are popular throughout the county, a recommendation of the restaurant to open can be given. . Analysis . Getting an overview . First of all, let&#39;s have a look on our dataset describing the areas. . final_ds.head() . Zip Code City Community Estimated Median Income Longitude Latitude Total Population Median Age Total Males Total Females Total Households Average Household Size . 1 90001 | Los Angeles | Los Angeles (South Los Angeles), Florence-Graham | 43360.0 | -118.24878 | 33.972914 | 57110 | 26.6 | 28468 | 28642 | 12971 | 4.40 | . 2 90002 | Los Angeles | Los Angeles (Southeast Los Angeles, Watts) | 37285.0 | -118.24845 | 33.948315 | 51223 | 25.5 | 24876 | 26347 | 11731 | 4.36 | . 3 90003 | Los Angeles | Los Angeles (South Los Angeles, Southeast Los ... | 40598.0 | -118.27600 | 33.962714 | 66266 | 26.3 | 32631 | 33635 | 15642 | 4.22 | . 4 90004 | Los Angeles | Los Angeles (Hancock Park, Rampart Village, Vi... | 49675.0 | -118.30755 | 34.077110 | 62180 | 34.8 | 31302 | 30878 | 22547 | 2.73 | . 5 90005 | Los Angeles | Los Angeles (Hancock Park, Koreatown, Wilshire... | 38491.0 | -118.30848 | 34.058911 | 37681 | 33.9 | 19299 | 18382 | 15044 | 2.50 | . Now we are going to take a look at the areas with the highest income and the highest population. . income_sorted = final_ds.sort_values(by=&#39;Estimated Median Income&#39;, ascending=False) income_top15 = income_sorted.iloc[0:14] fig = px.bar(income_top15, x=&quot;Estimated Median Income&quot;, y=&quot;City&quot;, orientation = &quot;h&quot;, color=&#39;Estimated Median Income&#39;, title=&#39;Distribution of Estimated Median Income&#39;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . . . pop_sorted = final_ds.sort_values(by=&#39;Total Population&#39;, ascending=False) pop_top15 = pop_sorted.iloc[0:14] fig = px.bar(pop_top15, y=&quot;Total Population&quot;, x=&quot;City&quot;, orientation = &quot;v&quot;, color=&#39;Total Population&#39;, title=&#39;Distribution of Population&#39;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . . . As we are primarily interested in the areas that have a high total population, let us add the income to this graph and get an overview on which areas in this group have the highest income. . fig = px.scatter(pop_top15, x=&quot;Estimated Median Income&quot;, y=&quot;Community&quot;, size=&quot;Total Population&quot;, log_x=True, color=&quot;Total Population&quot;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . . . In this graph the population determines the bubble size. So there are four areas that stand out: . City Population Median Income . Norwalk | 105,6K | 70,7K | . Lake View Terrace, Sylmar | 91,7K | 74K | . La Puente, Valinda | 85K | 71,2K | . Hansen Hills, Pacoima | 104K | 64K | . These four cities / neighbourhoods seem to be suitable areas, based on their combination of population and median income. We are going to see, if this assumption is confirmed going forward. . Clustering the dataset . from sklearn.cluster import KMeans grouped_clustering = final_ds.drop([&#39;Zip Code&#39;, &#39;City&#39;, &#39;Community&#39;, &#39;Longitude&#39;, &#39;Latitude&#39;, &#39;Total Males&#39;, &#39;Total Females&#39;], 1) grouped_clustering.head() . Estimated Median Income Total Population Median Age Total Households Average Household Size . 1 43360.0 | 57110 | 26.6 | 12971 | 4.40 | . 2 37285.0 | 51223 | 25.5 | 11731 | 4.36 | . 3 40598.0 | 66266 | 26.3 | 15642 | 4.22 | . 4 49675.0 | 62180 | 34.8 | 22547 | 2.73 | . 5 38491.0 | 37681 | 33.9 | 15044 | 2.50 | . sum_of_squared_distances = [] K = range(1,15) for k in K: kmeans = KMeans(n_clusters=k, init=&quot;k-means++&quot;, random_state=0).fit(grouped_clustering) sum_of_squared_distances.append(kmeans.inertia_) #kmeans.labels_ . import matplotlib.pyplot as plt plt.plot(K, sum_of_squared_distances, &#39;bx-&#39;) plt.xlabel(&#39;k&#39;) plt.ylabel(&#39;Sum_of_squared_distances&#39;) plt.title(&#39;Elbow Method For Optimal k&#39;) plt.show() . According to the elbow method I chose a k of 6 going forward. So let&#39;s do the clustering again with the determined k value. Then I will add the cluster labels to my dataset and print out a summarization of the created clusters. . kmeans = KMeans(n_clusters=6, init=&quot;k-means++&quot;, random_state=0).fit(grouped_clustering) # add the labels to the dataset final_ds.insert(0, &#39;Cluster Label&#39;, kmeans.labels_) . cluster_df = final_ds.groupby(&#39;Cluster Label&#39;).mean() cluster_df . Zip Code Estimated Median Income Longitude Latitude Total Population Median Age Total Males Total Females Total Households Average Household Size . Cluster Label . 0 90988.629630 | 106149.203704 | -118.326722 | 34.101526 | 29781.925926 | 41.064815 | 14563.444444 | 15218.481481 | 11475.425926 | 2.544815 | . 1 90949.500000 | 51305.386364 | -118.201435 | 34.097584 | 18681.204545 | 35.754545 | 9459.613636 | 9221.590909 | 6144.704545 | 2.858409 | . 2 90624.000000 | 155063.444444 | -118.425995 | 34.024770 | 17967.666667 | 43.838889 | 8777.833333 | 9189.833333 | 7020.722222 | 2.479444 | . 3 91153.090909 | 57912.863636 | -118.190515 | 34.113848 | 83146.500000 | 30.468182 | 41257.500000 | 41889.000000 | 22069.545455 | 3.768182 | . 4 90657.634921 | 53158.555556 | -118.258781 | 34.038015 | 49959.714286 | 32.455556 | 24713.476190 | 25246.238095 | 15571.158730 | 3.256984 | . 5 91012.205128 | 79295.179487 | -118.214638 | 34.056455 | 28459.230769 | 38.342308 | 13819.230769 | 14640.000000 | 10393.205128 | 2.747949 | . Let us clean this up a bit and add a new column, that will help us to chose a cluster going forward. . clusters = cluster_df[[&#39;Estimated Median Income&#39;, &#39;Total Population&#39;, &#39;Median Age&#39;, &#39;Total Households&#39;, &#39;Average Household &#39; &#39;Size&#39;]] clusters[&#39;Decision Factor&#39;] = ( ( clusters[&#39;Total Population&#39;] * 1.2 ) * clusters[&#39;Estimated Median Income&#39;]) / 100000 clusters_r = clusters.round(2) clusters_r clusters_sorted = clusters_r.sort_values(by=&#39;Decision Factor&#39;, ascending=False) clusters_sorted . &lt;ipython-input-19-ab34df8160b4&gt;:5: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy . Estimated Median Income Total Population Median Age Total Households Average Household Size Decision Factor . Cluster Label . 3 57912.86 | 83146.50 | 30.47 | 22069.55 | 3.77 | 57783.02 | . 0 106149.20 | 29781.93 | 41.06 | 11475.43 | 2.54 | 37935.93 | . 2 155063.44 | 17967.67 | 43.84 | 7020.72 | 2.48 | 33433.54 | . 4 53158.56 | 49959.71 | 32.46 | 15571.16 | 3.26 | 31869.43 | . 5 79295.18 | 28459.23 | 38.34 | 10393.21 | 2.75 | 27080.16 | . 1 51305.39 | 18681.20 | 35.75 | 6144.70 | 2.86 | 11501.36 | . Looking at these clusters, they can be described as the following: . Name Income Population Age . Cluster 0 | High | Medium | Older | . Cluster 1 | Low | Low | Young | . Cluster 2 | Very High | Low | Older | . Cluster 3 | Medium | Very High | Very Young | . Cluster 4 | Low | High | Very Young | . Cluster 5 | High | Medium | Young | . So based on this information I am going to choose Cluster 3 for further evaluation and as the cluster where I will pick an area from. This cluster has a medium income combined with a very high population. It also contains the youngest median age, which also can be considered for choosing the food venue category. . cluster3 = final_ds.loc[final_ds[&#39;Cluster Label&#39;] == 3, final_ds .columns[[1] + list(range(2, final_ds.shape[1]))]] cluster3.shape . (22, 12) . This cluster contains 22 areas in Los Angeles County, CA. We are going to have a look on them on the map using Folium. . from geopy.geocoders import Nominatim # initialize the map address = &#39;Los Angeles County, CA&#39; geolocator = Nominatim(user_agent=&quot;la_explorer&quot;) location = geolocator.geocode(address) latitude = location.latitude longitude = location.longitude . import matplotlib.cm as cm import matplotlib.colors as colors import folium import numpy as np # create map map_clusters = folium.Map(location=[latitude, longitude], zoom_start=11) cluster3 = final_ds.loc[final_ds[&#39;Cluster Label&#39;] == 3] # set color scheme for the clusters, 6 is our number of clusters x = np.arange(6) ys = [i + x + (i*x)**2 for i in range(6)] colors_array = cm.rainbow(np.linspace(0, 1, len(ys))) rainbow = [colors.rgb2hex(i) for i in colors_array] # add markers to the map markers_colors = [] for lat, lon, poi, cluster in zip(cluster3[&#39;Latitude&#39;], cluster3[&#39;Longitude&#39;], cluster3[&#39;Zip Code&#39;], cluster3[&#39;Cluster Label&#39;]): label = folium.Popup(str(poi) + &#39; Cluster &#39; + str(cluster), parse_html=True) folium.CircleMarker( [lat, lon], radius=5, popup=label, color=rainbow[cluster-1], fill=True, fill_color=rainbow[cluster-1], fill_opacity=0.7).add_to(map_clusters) map_clusters . As one can see, most of our areas in more densely populated areas and in the vicinity of the city of Los Angeles. Now let us add the &quot;decision factor&quot; again and calculate it for every single region in cluster 3. . cluster3[&#39;Decision Factor&#39;] = ( ( cluster3[&#39;Total Population&#39;] * 1.2 ) * cluster3[&#39;Estimated Median Income&#39;]) / 100000 cluster3_r = cluster3.round(2) cluster3_sorted = cluster3_r.sort_values(by=&#39;Decision Factor&#39;, ascending=False) cluster3_sorted.head(10) . cluster3_top5 = cluster3_sorted.iloc[0:5] fig = px.bar(cluster3_top5, x=&#39;Decision Factor&#39;, y=&#39;Community&#39;, color=&#39;Average Household Size&#39; ) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . So there are three areas that stand out: . Norwalk, with a population of 105,6k and an income of $70,6k; it has the oldest median age of the three communities and the largest population. | Lake View Terrace in Sylmar, with a population of 91,7k and an income of $74k; it has the highest income of the group and the lowest population. | Hansen Hills in Pacoima, with a population 104,7k and an income of $63,8k. It has the youngest median age of the three and is very close to Norwalk in terms of population, but it has the lowest income. | . Looking back at the initial analysis we did for all areas in Los Angeles County, we find that these three areas were also part auf the group we found, based on their features. So through the clustering we could confirm our initial findings. . Exploring local food venues . Using Foursquare, we are going to query the existing food venues in the three areas. . We will use a radius of 4 kilometres around the center of every community. I will also use the city and zip code from the response to filter out results from Foursquare that actually do not belong to the city community we are exploring. . import itertools top3 = cluster3_sorted.iloc[0:3] venues_list=[] # Get the local food venues for all 3 of our communities for _, record in top3.iterrows(): offset = 0 for _ in itertools.repeat(None, 4): url = &#39;https://api.foursquare&#39; &#39;.com/v2/venues/explore?&amp;client_id={}&amp;client_secret={}&amp;v={}&amp;ll={},&#39; &#39;{}&amp;radius={}&amp;limit={}&amp;offset={}&amp;categoryId={}&#39;.format( CLIENT_ID, CLIENT_SECRET, VERSION, record[&#39;Latitude&#39;], record[&#39;Longitude&#39;], 4000, 50, offset, &#39;4d4b7105d754a06374d81259&#39;) # increase the offset for the next run offset += 50 # try to read the items from the Foursquare response and loop over them try: results = requests.get(url).json()[&quot;response&quot;][&#39;groups&#39;][0][&#39;items&#39;] for v in results: # get the city name from the Foursquare response, if possible try: city = v[&#39;venue&#39;][&#39;location&#39;][&#39;city&#39;] except: city = str(record[&#39;City&#39;]) # get the zip code from the Foursquare response, if possible try: postalCode = str(v[&#39;venue&#39;][&#39;location&#39;][&#39;postalCode&#39;]) except: postalCode = str(record[&#39;Zip Code&#39;]) venues_list.append((record[&#39;Zip Code&#39;], record[&#39;Community&#39;], record[&#39;Latitude&#39;], record[&#39;Longitude&#39;], v[&#39;venue&#39;][&#39;name&#39;], v[&#39;venue&#39;][&#39;categories&#39;][0][&#39;name&#39;], city, postalCode)) except: # there are no more results that Foursquare can deliver break # create a dataframe from all venues we have found for all 3 areas nearby_venues = pd.DataFrame(venues_list, columns=[&#39;Zip Code&#39;, &#39;Community&#39;, &#39;Zip Code Latitude&#39;, &#39;Zip Code Longitude&#39;, &#39;Venue&#39;, &#39;Venue Category&#39;, &#39;City&#39;, &#39;PostalCode&#39;]) nearby_venues.count() . venues_cleaned = nearby_venues.loc[ nearby_venues[&#39;City&#39;].isin([&#39;Norwalk&#39;, &#39;Sylmar&#39;, &#39;Pacoima&#39;])] venues_cleaned.count() . We found 167 food venues across all 3 areas. In the next step we will group the food venues by category and city. We can use the count of food venues per category to visualize the distribution across the communities. . categs = venues_cleaned[[&#39;City&#39;, &#39;Venue Category&#39;]] # count the number of restaurants per city and category categs_count = categs.groupby([&#39;City&#39;, &#39;Venue Category&#39;]).size().to_frame( &#39;Count&#39;).reset_index() # sort the result by city and count categs_sorted = categs_count.sort_values(by=[&#39;City&#39;, &#39;Count&#39;], ascending=False) categs_sorted . categs_graph = categs_sorted.loc[categs_sorted[&#39;Count&#39;] &gt; 1] fig = px.bar(categs_graph, y=&quot;Venue Category&quot;, x=&quot;Count&quot;, title=&#39;Combined Distribution of Food Venues&#39;, orientation=&#39;h&#39;, color = &#39;City&#39; ) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) #fig.show(renderer=&#39;notebook_connected&#39;) . Having a look at the distribution of food venues across the three areas, we can make the following observations: . Mexican restaurants are the most common food venue overall | Fast Food restaurants are the second most common venue, but Norwalk has by far the most | Pacoima has the least restaurants overall and Norwalk the most, despite both of them are very close in population | There seems to be space for a Chinese or American Restaurant or a Donut Shop in Pacoima | Even sandwich and pizza places are not very common in Pacoima | Opening another fast food restaurant or mexican restaurant does not seem like a good idea | . Again, let us have a look on the most recommended food venues in the county for comparison: . top15 = sorted.iloc[0:14] fig = px.bar(top15, x=&quot;Venue Category&quot;, y=&quot;Count&quot;, title=&#39;Distribution of recommended food venue categories&#39;) #fig.show(renderer=&#39;notebook_connected&#39;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) . Choosing a restaurant to open . Bakeries are the fith most recommended venue category, but there is currently a maximum of 1 per area. So this could be a good option in any of the three communities. | Mexican and fast food restaurants are already very common and should not be chosen | There is an opportunity for a pizza place or a chinese resaturant in Pacoima | Pacoima in general has few food venues. Looking at the median income, any low price food venues could be a good opportunity. | Norwalk would be the best option according to population and income, but it is already very crowded with restaurants. A bakery seems to be the best option there. | . There are also multiple options for sushi restaurants, burger joints, japanese or thai restaurants in all three areas. Overall not looking bad! . Results and Discussion . Our analysis shows that there is a high variability in population, income and median age in the different areas of Los Angeles County, CA. So it was possible to identify multiple areas that fit the criteria of a relatively high median income and a high population. Using census and income data of all areas in Los Angeles County, we did a clustering to identify similar areas. By analysing the formed clusters there have been three areas identified that fit the criteria best. Norwalk, Lake View Terrace in Sylmar and Hansen Hills in Pacoima. . They are slightly different in income, population and age and also very different in their local distribution of available food venues. The final area could be picked on which of these factors matters to the stakeholders most. I will pick Norwalk as the final area for a food venue, because it offers the best combination of a high population and a good income out of these three areas. . By analysing the most recommended food venue categories across the whole county, we found that mexican restaurants are by far the most often recommended venue. After them pizza places, fast food restaurants, chinese restaurants and bakeries follow in that order. To give a recommendation for a food venue to open in Norwalk, we can compare the local distribution of food venues what was recommended the most in the county. By looking at Norwalk we found that there are already many mexican restaurants (12) and fast food restaurants (15). Pizza places (7) and chinese restaurants (5) area also recommended in a higher number, so opening a restaurant in one of those categories would be better, but there is still some competition. What stands out is that there is currently only one bakery recommended by Foursquare in Norwalk. Looking at the distribution of recommendations in the county, bakeries are the fifth most recommended venue category. Because of this, I would recommend opening a bakery in Norwalk, CA to the stakeholders. . Purpose of this analysis was to identify a possible area and food venue type for a new restaurant in Los Angeles County, CA based on a very limited amount of factors. Analysing census data and existing food venues is only one part on the way to find a location for opening a new restaurant. Other factors that also play a role are for example available spaces, rent costs, other venues in the area. This analysis serves as a starting point for finding possible locations, but further analysis needs to be done by the stakeholders. . Conclusion . The purpose of this project was to find a possible location for a new restaurant in Los Angeles County, CA. The desire from the stakeholders was to identify locations that offer a good balance between median income and number of inhabitants, although income shall be rated slightly more important than population. In addition, the idea was to identify possible food venue categories by comparing recommended venues across the country with the local venues in the different areas. So for this there were census and income data combined to identify areas that fit the criteria. A clustering was performed, to group the communities in Los Angeles County using their income and population. Then the cluster was chosen that fit the former mentioned criteria the most. From this cluster the top 3 areas were chosen, that had the best balance between income and population. This way the best three candidates for a new restaurant location were identified. . The next step was to analyze the local food venue categories. For this the local venues in a 4 km radius were identified and grouped. This grouping was then compared with the distribution of the most recommended food venue categories across the whole county. In doing so, opportunities for new restaurants in any of the three chosen communities have been identified. . The final decision can be made by the stakeholders, based on the recommendations given in this project. This decision for a locality can be based on income, population or median age of the areas. The decision for a venue category can be based on popular venues across the county, and the gaps in the local food offerings that have been identified. .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/ml/visualization/2021/06/24/capstone-project.html",
            "relUrl": "/ibm/data_science/ml/visualization/2021/06/24/capstone-project.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Plotly test",
            "content": "print(&quot;Hello!&quot;) . Hello! . from IPython.display import HTML, display import plotly.express as px import altair as alt df = px.data.iris() display(df.head()) fig = px.scatter(df, x=&quot;sepal_width&quot;, y=&quot;sepal_length&quot;) #HTML(fig.to_html()) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;)) . sepal_length sepal_width petal_length petal_width species species_id . 0 5.1 | 3.5 | 1.4 | 0.2 | setosa | 1 | . 1 4.9 | 3.0 | 1.4 | 0.2 | setosa | 1 | . 2 4.7 | 3.2 | 1.3 | 0.2 | setosa | 1 | . 3 4.6 | 3.1 | 1.5 | 0.2 | setosa | 1 | . 4 5.0 | 3.6 | 1.4 | 0.2 | setosa | 1 | . . . alt.Chart(df).mark_point().encode( x=&#39;sepal_width&#39;, y=&#39;sepal_length&#39; ) .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/pandas/numpy/2021/03/11/PLOTLY.html",
            "relUrl": "/ibm/data_science/pandas/numpy/2021/03/11/PLOTLY.html",
            "date": " • Mar 11, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Data Science Basics Intro",
            "content": "import yfinance as yf import pandas as pd import requests from bs4 import BeautifulSoup # import plotly.graph_objects as go # from plotly.subplots import make_subplots # from IPython.display import HTML # # def make_graph(stock_data, revenue_data, stock): # fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=(&quot;Historical Share Price&quot;, &quot;Historical Revenue&quot;), vertical_spacing = .3) # fig.add_trace(go.Scatter(x=pd.to_datetime(stock_data.Date, infer_datetime_format=True), y=stock_data.Close.astype(&quot;float&quot;), name=&quot;Share Price&quot;), row=1, col=1) # fig.add_trace(go.Scatter(x=pd.to_datetime(revenue_data.Date, infer_datetime_format=True), y=revenue_data.Revenue.astype(&quot;float&quot;), name=&quot;Revenue&quot;), row=2, col=1) # fig.update_xaxes(title_text=&quot;Date&quot;, row=1, col=1) # fig.update_xaxes(title_text=&quot;Date&quot;, row=2, col=1) # fig.update_yaxes(title_text=&quot;Price ($US)&quot;, row=1, col=1) # fig.update_yaxes(title_text=&quot;Revenue ($US Millions)&quot;, row=2, col=1) # fig.update_layout(showlegend=False, # height=900, # title=stock, # xaxis_rangeslider_visible=True) # fig2 = fig.to_html() # HTML(fig2) . tsla = yf.Ticker(&#39;TSLA&#39;) tesla_data = tsla.history(period=&#39;max&#39;) tesla_data.reset_index(inplace=True) tesla_data.head() . Date Open High Low Close Volume Dividends Stock Splits . 0 2010-06-29 | 3.80 | 5.00 | 3.51 | 4.78 | 93831500 | 0 | 0.0 | . 1 2010-06-30 | 5.16 | 6.08 | 4.66 | 4.77 | 85935500 | 0 | 0.0 | . 2 2010-07-01 | 5.00 | 5.18 | 4.05 | 4.39 | 41094000 | 0 | 0.0 | . 3 2010-07-02 | 4.60 | 4.62 | 3.74 | 3.84 | 25699000 | 0 | 0.0 | . 4 2010-07-06 | 4.00 | 4.00 | 3.17 | 3.22 | 34334500 | 0 | 0.0 | . url = &#39;https://www.macrotrends.net/stocks/charts/TSLA/tesla/revenue&#39; html_data = requests.get(url).text soup = BeautifulSoup(html_data,&quot;html5lib&quot;) tesla_revenue = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Revenue&#39;]) quarterly = soup.findAll(&quot;table&quot;)[1].find(&quot;tbody&quot;) for row in quarterly.find_all(&quot;tr&quot;): col = row.find_all(&quot;td&quot;) date = col[0].text revenue = col[1].text.replace(&quot;$&quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;) tesla_revenue = tesla_revenue.append({&quot;Date&quot;:date, &quot;Revenue&quot;:revenue}, ignore_index=True) tesla_revenue.head() tesla_revenue.dropna(inplace=True) tesla_revenue = tesla_revenue[tesla_revenue[&#39;Revenue&#39;] != &quot;&quot;] tesla_revenue.tail() . Date Revenue . 41 2010-09-30 | 31 | . 42 2010-06-30 | 28 | . 43 2010-03-31 | 21 | . 45 2009-09-30 | 46 | . 46 2009-06-30 | 27 | . import altair as alt alt.Chart(tesla_revenue).mark_line().encode( x=&#39;Date:T&#39;, y=&#39;Revenue:N&#39; ) # make_graph(tesla_data, tesla_revenue, &#39;Tesla Stock Data&#39;) .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/pandas/numpy/2021/03/10/IBM-DS-BASICS.html",
            "relUrl": "/ibm/data_science/pandas/numpy/2021/03/10/IBM-DS-BASICS.html",
            "date": " • Mar 10, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Creational Design Patterns",
            "content": "# a class of which only a single instance can exist # Ensure a class is instantiated only once, and provide a global point of access to it # When: # - no clear owner of the object, i. e. a global object (e. g. logger) # - when you want to use lazy instantiation # - when you need a single global way to access the object # python offers a global object pattern . class Logger: __instance = None def __init__(self): raise RuntimeError(&#39;Call get_instance() instead&#39;) @classmethod def get_instance(cls): if cls.__instance is None : print(&#39;No instance exists, creating a new one&#39;) cls.__instance = cls.__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger1 = Logger.get_instance() logger1 . logger2 = Logger.get_instance() . logger2 . # new is always called first -&gt; it creates the instance, cls is reference to not yet existing instance # init is used to initialize the existing instance -&gt; self is a reference to the instance class PythonicLogger: __instance = None def __init__(self): print(&#39;Object initialized&#39;) # put your custom code here # is called every time - could be expensive def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(PythonicLogger, cls).__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger3 = PythonicLogger() logger3 . logger4 = PythonicLogger() logger4 . class SuperLogger: __instance = None def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(SuperLogger, cls).__new__(cls) # Place all initialization code here else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger5 = SuperLogger() logger5 . logger6 = SuperLogger() logger6 . logger5 == logger6 . # Global Objects which expose methods import logger . logger.INFO . logger.WARNING . file_logger = logger.FILE_LOGGER file_logger.log(&quot;logging message&quot;) . # Separate the creation of objects from their use # Class creation or Object creation # Class-creation patterns use inheritance # Object-creation patterns use delegation # Factory method is specified in base class, implemented in derived classes # Creates an instance of several derived classes # Define an interface for creating an object, but let subclasses decide which class to instantiate # Used to postpone instantiation - responsibility passes from base class to derived classes # Factory method -&gt; create an instance of any of many derived classes # Abstract F. pattern -&gt; create an instance of any one of many families of derived classes # Abstract Factory: create instances of several families of classes # encapsulate platform dependencies # Use case: Working with Oracle or MS-SQL databases -&gt; each represents a family of classes # Microsoft Factory | Oracle Factory . class Product: def __init__(self, name, price): self.__name = name self.__price = price def get_price(self): return self.__price . class MacBookAir(Product): def __init__(self, memory, os): Product.__init__(self, &#39;MacBookAir&#39;, 1031) self.__memory = memory self.__os = os class AppleIPad(Product): def __init__(self, generation): Product.__init__(self, &#39;AppleIPad&#39;, 529) self.__generation = generation class AppleIWatch(Product): def __init__(self): Product.__init__(self, &#39;AppleIWatch&#39;, 264) . class ProductFactory(): @staticmethod def create(item_name, *args): if item_name == &#39;MacBookAir&#39;: return MacBookAir(*args) elif item_name == &#39;AppleIPad&#39;: return AppleIPad(*args) elif item_name == &#39;AppleIWatch&#39;: return AppleIWatch(*args) . air = ProductFactory.create(&#39;MacBookAir&#39;, &#39;16GB&#39;, &#39;Sierra&#39;) air.__dict__ . ipad = ProductFactory.create(&#39;AppleIPad&#39;, &#39;2nd&#39;) ipad.__dict__ . iwatch = ProductFactory.create(&#39;AppleIWatch&#39;) iwatch.__dict__ . https://realpython.com/factory-method-python/ . import json import xml.etree.ElementTree as et class Movie: def __init__(self, movie_id, name, director): self.movie_id = movie_id self.name = name self.director = director . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) elif fmt == &#39;XML&#39;: movie_info = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_info, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_info, &#39;director&#39;) director.text = movie.director return et.tostring(movie_info, encoding=&#39;unicode&#39;) else: raise ValueError(fmt) . movie = Movie(&#39;578&#39;, &#39;Avengers:End Game&#39;, &#39;Russo brothers&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . serializer.serialize(movie, &#39;YAML&#39;) . Complex logical code uses if/elif/else structures to change the behavior of an application. Using if/elif/else conditional structures makes the code harder to read, harder to understand, and harder to maintain. . When a new format is introduced: The method will have to change to implement the serialization to that format. . | When the movie object changes: Adding or removing properties to the Song class will require the implementation to change in order to accommodate the new structure. . | When the string representation for a format changes (plain JSON vs JSON API): The .serialize() method will have to change if the desired string representation for a format changes because the representation is hard-coded in the .serialize() method implementation. . | . Refactoring Code Into the Desired Interface . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: return self._serialize_to_json(movie) elif fmt == &#39;XML&#39;: return self._serialize_to_xml(movie) else: raise ValueError(format) def _serialize_to_json(self, movie): movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) def _serialize_to_xml(self, movie): movie_element = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_element, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_element, &#39;director&#39;) director.text = movie.director return et.tostring(movie_element, encoding=&#39;unicode&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . . Provide an interface for creating families of related or dependent objects without specifying their concrete classes. . An abstract factory is a factory that returns factories.A normal factory can be used to create sets of related objects. An abstract factory returns factories. Thus, an abstract factory is used to return factories that can be used to create sets of related objects. . When the system needs to be independent of how its object are created, composed, and represented. | When the family of related objects has to be used together, then this constraint needs to be enforced. | When you want to provide a library of objects that does not show implementations and only reveals interfaces. | When the system needs to be configured with one of a multiple family of objects. | . import abc . create an interface for Toys and color . class Toy(metaclass=abc.ABCMeta): @abc.abstractmethod def show(self): pass class Color(metaclass=abc.ABCMeta): @abc.abstractmethod def show_color(self): pass . class Car(Toy): def show(self): print(&quot;Remote controlled car&quot;) class ActionFigure(Toy): def show(self): print(&quot;Captain America action figure&quot;) class ConstructionToy(Toy): def show(self): print(&quot;Lego&quot;) . class Red(Color): def show_color(self): print(&quot;red&quot;) class Green(Color): def show_color(self): print(&quot;green&quot;) class Blue(Color): def show_color(self): print(&quot;blue&quot;) . car = Car() red = Red() red.show_color(), car.show() . red Remote controlled car . (None, None) . lego = ConstructionToy() green = Green() green.show_color(), lego.show() . green Lego . (None, None) . class AbstractFactory(metaclass=abc.ABCMeta): @abc.abstractmethod def get_color(self): pass @abc.abstractmethod def get_toy(self): pass . Create concrete classes implementing the same interface. . create Factory classes extending AbstractFactory . class ColorfulToysFactory(AbstractFactory): def get_toy(self, toy_type): if toy_type == None: return None if toy_type == &quot;car&quot;: return Car() elif toy_type == &quot;action figure&quot;: return ActionFigure() elif toy_type == &quot;construction toy&quot;: return ConstructionToy() return None def get_color(self, color_type): if color_type == None: return None if color_type == &quot;red&quot;: return Red() elif color_type == &quot;green&quot;: return Green() elif color_type == &quot;blue&quot;: return Blue() return None . RED_CAR = &#39;red_car&#39; BLUE_LEGO = &#39;blue_lego&#39; GREEN_ACTION_FIGURE = &#39;green_action_figure&#39; . Use the FactoryProducer to get AbstractFactory in order to get factories of concrete classes by passing an information such as type . class ColorfulToysProducer: __colorful_toys_factory = ColorfulToysFactory() @classmethod def get_toy_and_color(cls, choice): toy = None color = None if choice == RED_CAR: toy = cls.__colorful_toys_factory.get_toy(&#39;car&#39;) color = cls.__colorful_toys_factory.get_color(&#39;red&#39;) elif choice == BLUE_LEGO: toy = cls.__colorful_toys_factory.get_toy(&#39;construction toy&#39;) color = cls.__colorful_toys_factory.get_color(&#39;blue&#39;) elif choice == GREEN_ACTION_FIGURE: toy = cls.__colorful_toys_factory.get_toy(&#39;action figure&#39;) color = cls.__colorful_toys_factory.get_color(&#39;green&#39;) return toy, color . toy, color = ColorfulToysProducer.get_toy_and_color(RED_CAR) toy, color . (&lt;__main__.Car at 0x253feb8a748&gt;, &lt;__main__.Red at 0x253ff224fc8&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(BLUE_LEGO) toy, color . (&lt;__main__.ConstructionToy at 0x253feb611c8&gt;, &lt;__main__.Blue at 0x253feb61548&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(GREEN_ACTION_FIGURE) toy, color . (&lt;__main__.ActionFigure at 0x253ff09f208&gt;, &lt;__main__.Green at 0x253ff09f3c8&gt;) . # Separate the construction of an object from representation # allow same construction process for many representations # parse a complex representation, create different objects # Consider a SQL query builder class # allows step-by-step creation of a SQL query # Query is a complex entity with many different parts # Applications might build once, run multiple times # Separates object construction from its representation # parse a complex construction process into simple constituent operations . class Mobile: def __init__(self, name, weight, screen_size, ram, os, camera_mp, battery): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(name=&quot;Samsung S10&quot;, weight = &quot;157g&quot;, screen_size = &quot;6.1 inch&quot;, ram = &quot;8GB&quot;, os = &quot;android 9.0&quot;, camera_mp = &quot;12 megapixel&quot;, battery = &quot;3400 mAh&quot;) . samsung_s10.show() . name: Samsung S10 weight: 157g screen_size: 6.1 inch ram: 8GB os: android 9.0 camera_mp: 12 megapixel battery: 3400 mAh . to get rid of the long list of parameters we can have the features in the main program but directly setting attributes in the client program is wrong, it goes against encapsulate what varies principle . this is prone to errors and maintenance unfriendly . class Mobile(): def __init__(self): self.name = None self.weight = None self.screen_size = None self.ram = None self.os = None self.camera_mp = None self.battery = None def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . s10 = Mobile() . s10.name = &quot;Samsung S10&quot; s10.screen_size = &quot;6.1 inch&quot;, s10.os = &quot;android 9.0&quot;, s10.camera_mp = &quot;12 megapixel&quot;, s10.battery = &quot;3400 mAh&quot; . s10.show() . name: Samsung S10 weight: None screen_size: (&#39;6.1 inch&#39;,) ram: None os: (&#39;android 9.0&#39;,) camera_mp: (&#39;12 megapixel&#39;,) battery: 3400 mAh . now the features have been encapsulated in a seperate class called MyMobile the build method instantiates a new mobile object and encapsulates setting of sttributes | . class MyMobileBuilder(): def __init__(self): self.__mobile = Mobile() def get_mobile(self): return self.__mobile def build_name(self, name): self.__mobile.name = name def build_memory(self, ram): self.__mobile.ram = ram def build_camera(self, camera_mp): self.__mobile.camera_mp = camera_mp def build_otherfeatures(self, weight, screen_size, os, battery): self.__mobile.weight = weight self.__mobile.screen_size = screen_size self.__mobile.os = os self.__mobile.battery = battery . build the mobile, get the finished product and show the features . we solved - . long parameter list problem | encapsulating attributes | . builder = MyMobileBuilder() . builder.build_name(&#39;Samsung S10&#39;) builder.build_memory(&#39;8GB&#39;) builder.build_camera(&#39;16 megapixels&#39;) . mobile = builder.get_mobile() . mobile.show() . name: Samsung S10 weight: None screen_size: None ram: 8GB os: None camera_mp: 16 megapixels battery: None . class Mobile: def __init__(self, name, weight=&#39;157gm&#39;, screen_size=&#39;5inches&#39;, ram=&#39;8GB&#39;, os=&#39;Android&#39;, camera_mp=&#39;16 megapixels&#39;, battery=&#39;3400 mAh&#39;): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(&#39;Samsung S10&#39;) samsung_s10.show() . name: Samsung S10 weight: 157gm screen_size: 5inches ram: 8GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . samsung_s8 = Mobile(&#39;Samsung S8&#39;, screen_size=&#39;4.4inches&#39;, ram=&#39;4GB&#39;) samsung_s8.show() . name: Samsung S8 weight: 157gm screen_size: 4.4inches ram: 4GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . # Used when the cost of initializing objects is high # Number of objects in use at a time is low # Rate of object instantiation is high # Pools used to cache and manage objects # Avoid creating new objects, when an existing one is available # Reuse objects rather than incur the cost of creating one # common example: thread pools # some processes are embarrassingly parallel # threads are expensive to create and free up # use a thread pool -&gt; mitigates the overhead of pool creation # avoids needless re-instantiation and expensive acquisition of resources . class Connection: def __init__(self): self.__is_used = False # Imagine a very heavy-duty initialization process here # to set up the database connections and connect self.connect_to_database() def acquire(self): self.__is_used = True def release(self): self.__is_used = False def is_used(self): return self.__is_used def connect_to_database(self): pass . class ConnectionPool: def __init__(self, num_connections): self.__num_connections = num_connections self.__connections = [] for i in range(num_connections): self.__connections.append(Connection()) def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(3) . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253ff03aac8&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . conn_4 = pool.acquire() conn_4 is None . True . pool.release(conn_3) . conn_4 = pool.acquire() conn_4 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . pool.release(conn_2) . conn_5 = pool.acquire() conn_5 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . class ConnectionPool: __instance = None def __new__(cls, num_connections): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(ConnectionPool, cls).__new__(cls) cls.__instance.__num_connections = num_connections cls.__instance.__connections = [] for i in range(num_connections): cls.__instance.__connections.append(Connection()) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(2) . No instance exists, creating a new one . pool = ConnectionPool(2) . A previously created instance exists, returning that same one . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253feeed048&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253feeed308&gt; . conn_3 = pool.acquire() conn_3 is None . True . pool.release(conn_2) . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253feeed308&gt; . .",
            "url": "https://elydora.github.io/DataScienceBlog/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "relUrl": "/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "date": " • Jun 28, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Classes - Introduction",
            "content": "# Classes -&gt; have State (Attributes) and Behavior (Perform Actions) . # each entity is known as an instance or object # each objects has its own independent existence . # attributes are called member variables # functions perform actions on the member variables -&gt; called member functions # no limit for vars/functions . # Class variables -&gt; associated with the class itself; shared by all objects of the class # - declared outside of any method # - referred to by class name # Instance variables -&gt; associated with objects of a class; exclusive property # - declared inside any method # - referred using the self keyword . . # tries to capture the similarities and differences in real-world entities # Portray relationships # base, parent, super class | derived, child class, subclass . # Polymorphism - the ability of an object to behave in multiple ways # Encapsulation of data # Clear modular structure for code # Provides abstractions and data encapsulation # Easy to maintain and reuse code # Model real-world entities .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Classes - Inheritance",
            "content": "class Shape: pass class Shape(): pass class Shape(object): pass . class Shape: def __init__(self, shape_type): self.__type = shape_type def get_type(self): return self.__type . circle = Shape(&quot;circle&quot;) type(circle) . __main__.Shape . circle.get_type() . &#39;circle&#39; . square = Shape(&quot;square&quot;) type(square) . __main__.Shape . class Shape: def __init__(self, shape_type, color=&quot;Red&quot;): # optional self.__type = shape_type self.__color = color def get_type(self): return self.__type def get_color(self): return self.__color def get_area(self): pass def get_perimeter(self): pass . circle = Shape(&quot;circle&quot;) circle.get_color() . &#39;Red&#39; . class Circle(Shape): pass . circle = Circle(&quot;circle&quot;) . type(circle) . __main__.Circle . class Circle(Shape): def __init__(self): Shape.__init__(self, &quot;circle&quot;) . class Square(Shape): def __init__(self): Shape.__init__(self, &quot;square&quot;) . circle = Circle() square = Square() circle.get_type(), square.get_type() . (&#39;circle&#39;, &#39;square&#39;) . class Circle(Shape): def __init__(self, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) . circle = Circle() circle.get_color() . &#39;green&#39; . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . circle = Circle(5, color=&quot;orange&quot;) circle.get_area() . 78.53981633974483 . help(Circle) . Help on class Circle in module __main__: class Circle(Shape) | Circle(radius, color=&#39;green&#39;) | | Method resolution order: | Circle | Shape | builtins.object | | Methods defined here: | | __init__(self, radius, color=&#39;green&#39;) | Initialize self. See help(type(self)) for accurate signature. | | get_area(self) | | get_perimeter(self) | | - | Methods inherited from Shape: | | get_color(self) | | get_type(self) | | - | Data descriptors inherited from Shape: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): super().__init__(self, &quot;circle&quot;, color) # super is also possible self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . issubclass(Circle, Shape) . True . class Father: pass class Mother: pass . class Child1(Father, Mother): pass . help(Child1) . Help on class Child1 in module __main__: class Child1(Father, Mother) | Method resolution order: | Child1 | Father | Mother | builtins.object | | Data descriptors inherited from Father: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . class Father: def height(self): print(&quot;I have inherited my height from my father&quot;) class Mother: def intelligence(self): print(&quot;I have inherited my intelligence from my mother&quot;) class Child(Father, Mother): def experience(self): print(&quot;My experience are all my own&quot;) . c = Child() c.height() . I have inherited my height from my father . c.intelligence() . I have inherited my intelligence from my mother . class Hominidae(): def communication(self): print(&quot;They use auditory calls and visual cues.&quot;) def walk(self): print(&quot;They are knuckle-walkers, used to hang and swing from one tree to another.&quot;) class Human(Hominidae): def communication(self): print(&quot;They use language to communicate.&quot;) def walk(self): print(&quot;They are bipeds.&quot;) class Gorilla(Hominidae): def communication(self): print(&quot;They use twenty-five distinct vocalizations to communicate.&quot;) def walk(self): print(&quot;They are knuckle-walkers.&quot;) hominidae_1 = Hominidae() human_1 = Human() gorilla_1 = Gorilla() . hominidae_1.communication() human_1.communication() gorilla_1.communication() . They use auditory calls and visual cues. They use language to communicate. They use twenty-five distinct vocalizations to communicate. . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Classes - Getting Started",
            "content": "class Student: pass . object_1 = Student() . type(object_1) . __main__.Student . object_2 = Student() . object_1 . &lt;__main__.Student at 0x288a7e26148&gt; . object_2 . &lt;__main__.Student at 0x288a88928c8&gt; . isinstance(object_1, Student) . True . object_1.name = &#39;Michel&#39; object_1.email = &#39;Michel@xyz.com&#39; . object_1.name . &#39;Michel&#39; . object_1.school . AttributeError Traceback (most recent call last) &lt;ipython-input-12-68b03d9bbaba&gt; in &lt;module&gt; -&gt; 1 object_1.school AttributeError: &#39;Student&#39; object has no attribute &#39;school&#39; . object_3 = Student() object_3.name . AttributeError Traceback (most recent call last) &lt;ipython-input-13-b5626ff88877&gt; in &lt;module&gt; 1 object_3 = Student() -&gt; 2 object_3.name AttributeError: &#39;Student&#39; object has no attribute &#39;name&#39; . class Student: name = &quot;&quot; score = 0 active = True . s1 = Student() . s1.name = &quot;John&quot; s1.score = 50 s1.name, s1.score, s1.active . (&#39;John&#39;, 50, True) . # special methods are marked with __methodname__ class Student: def __init__(self): # can be anything, but self is standard print(&#39;Initialize called!&#39;) . s1 = Student() . Initialize called! . s2 = Student() s3 = Student() . Initialize called! Initialize called! . class Student: def __init__(self, name): # can be anything, but self is standard self.name = name # self refers to the current instance self.mail = name + &quot;.&quot; + &quot;@xyz.com&quot; . s1 = Student(&quot;Felix&quot;) s1.mail . &#39;Felix.@xyz.com&#39; . del s1.mail s1.mail . AttributeError Traceback (most recent call last) &lt;ipython-input-8-0ed8e4b3810a&gt; in &lt;module&gt; 1 del s1.mail -&gt; 2 s1.mail AttributeError: &#39;Student&#39; object has no attribute &#39;mail&#39; . class Competition: # class variable raise_amount = 1.04 def __init__(self, name, prize): self.name = name self.prize = prize def raise_prize(self): self.prize = self.prize * raise_amount . debate = Competition(&#39;Debate&#39;, 500) print(debate.raise_amount) . 1.04 . Competition.raise_amount . 1.04 . debate.__dict__ . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500} . Competition.__dict__ . mappingproxy({&#39;__module__&#39;: &#39;__main__&#39;, &#39;raise_amount&#39;: 1.04, &#39;__init__&#39;: &lt;function __main__.Competition.__init__(self, name, prize)&gt;, &#39;raise_prize&#39;: &lt;function __main__.Competition.raise_prize(self)&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Competition&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Competition&#39; objects&gt;, &#39;__doc__&#39;: None}) . debate.raise_amount = 10 debate.__dict__ # new instance attribute is added . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500, &#39;raise_amount&#39;: 10} . class Competition: def __init__(self, name, prize): self.name = name self.prize = prize self.participants = [] . debate = Competition(&#39;Debate&#39;, 500) debate.participants . [] . Competition.participants . AttributeError Traceback (most recent call last) &lt;ipython-input-5-ea531b615844&gt; in &lt;module&gt; -&gt; 1 Competition.participants AttributeError: type object &#39;Competition&#39; has no attribute &#39;participants&#39; . debate.participants.append(&#39;Alice&#39;) . debate.participants . [&#39;Alice&#39;] . # hack for private attributes: class Dog: def __init__(self, name, breed): self.__name = name self.__breed = breed def print_details(self): print(&#39;My name is %s and I am a %s&#39; % (self.__name, self.__breed)) . d1 = Dog(&quot;Moje&quot;, &quot;Golden Retriever&quot;) d1.print_details() . My name is Moje and I am a Golden Retriever . d1.__dict__ . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;} . d1.__name = &quot;Oba&quot; d1.print_details() # doesn&#39;t update . My name is Moje and I am a Golden Retriever . d1.__dict__ # new attribute created . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;, &#39;__name&#39;: &#39;Oba&#39;} . d1._Dog__breed = &quot;Husky&quot; # makes it harder to change, but can be changed d1.print_details() . My name is Moje and I am a Husky . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Classes - Advanced Functionality",
            "content": "class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes rowing = Competition(&quot;Rowing&quot;, 10000) . print(rowing) . &lt;__main__.Competition object at 0x000001D68AE718C8&gt; . rowing . &lt;__main__.Competition at 0x1d68ae718c8&gt; . class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes def __repr__(self): # representation for print function, if __str__ is not defined return &quot;(&#39;{}&#39;, {})&quot;.format(self.__name, self.__prize) . archery = Competition(&quot;Archery&quot;, 8000) . print(archery) . (&#39;Archery&#39;, 8000) . str(archery) # looks for special method __str__() . &#34;(&#39;Archery&#39;, 8000)&#34; . repr(archery) . &#34;(&#39;Archery&#39;, 8000)&#34; . class Competition: def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) . archery = Competition(&quot;Archery&quot;, &quot;United Kingdom&quot;, 7500) archery . Competition: Archery held in United Kingdom, prize: 7500 . print(archery) . &#39;Archery United Kingdom - 7500&#39; . 1 + 2 . 3 . int.__add__(1, 2) . 3 . str.__add__(&quot;a&quot;, &quot;b&quot;) . &#39;ab&#39; . class Savings: def __init__(self, amount): self.__amount = amount . s1 = Savings(1000) s2 = Savings(22000) . s1 + s2 . TypeError Traceback (most recent call last) &lt;ipython-input-27-07ecabcb1b41&gt; in &lt;module&gt; -&gt; 1 s1 + s2 TypeError: unsupported operand type(s) for +: &#39;Savings&#39; and &#39;Savings&#39; . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount . s1 = Savings(1000) s2 = Savings(22000) s1 + s2 . 23000 . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount def __sub__(self, other): return self.__amount - other.__amount . s1 = Savings(5000) s2 = Savings(457) s1 - s2 . 4543 . 1.0 * 2.1 . 2.1 . float.__mul__(1.0, 2.1) . 2.1 . float.__mul__(1, 2.1) . TypeError Traceback (most recent call last) &lt;ipython-input-37-ee0b82aa5938&gt; in &lt;module&gt; -&gt; 1 float.__mul__(1, 2.1) TypeError: descriptor &#39;__mul__&#39; requires a &#39;float&#39; object but received a &#39;int&#39; . 10 // 3 . 3 . int.__floordiv__(10, 3) . 3 . int.__mod__(4, 2) . 0 . int.__mod__(10, 3) . 1 . int.__pow__(6, 2) . 36 . len(&quot;test&quot;) . 4 . str.__len__(&quot;test&quot;) . 4 . some_list = [1, 4, 5, 7, 2] len(some_list) . 5 . class Participants: def __init__(self): self.__participants = [] def add_participants(self, name): self.__participants.append(name) def __len__(self): return len(self.__participants) . participants = Participants() participants.add_participants(&quot;Felix&quot;) participants.add_participants(&quot;Johan&quot;) participants.add_participants(&quot;Max&quot;) . len(participants) . 3 . class Wrestler: def __init__(self): self.__name = &quot;&quot; def set_name(self, name): print(&quot;setter method called&quot;) self.__name = name def get_name(self): print(&quot;getter method called&quot;) return self.__name def del_name(self): del self.__name name = property(get_name, set_name, del_name) . w = Wrestler() . w.name = &quot;Kart&quot; . setter method called . w.name . getter method called . &#39;Kart&#39; . class WrestlerNew: def __init__(self, name): self.__name = name @property # this is the method for accessing def name(self): print(&quot;getter method called&quot;) return self.__name @name.setter # this is the method for setting new vals def name(self, value): print(&quot;setter method called&quot;) self.__name = value @name.deleter def name(self): del self.__name . w1 = WrestlerNew(&quot;Rey&quot;) . w1.name . getter method called . &#39;Rey&#39; . class Competition: __raise_amount = 1.04 # class variable def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def raise_prize(self): self.__prize = self.__prize * self.__raise_amount def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) @classmethod def get_raise_amount(cls): return cls.__raise_amount @classmethod def set_raise_amount(cls, amount): cls.__raise_amount = amount . c1 = Competition(&quot;Running&quot;, &quot;Germany&quot;, 50000) . c1.set_raise_amount(2) . c1.get_raise_amount() . 2 . Competition.get_raise_amount() . 2 . class Rectangle: @staticmethod # cannot access class variables def area(x,y): return x * y . Rectangle.area(5,5) . 25 . from abc import ABC, abstractmethod class Hominidae(): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . chimpanzee = Hominidae() chimpanzee.behavior() . Blabla . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . paul = Human() paul.diet() . Omnivorous . class Hominidae(ABC): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h = Hominidae() . h.behavior() . Blabla . h.diet() . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . myra = Human() myra.diet() myra.walk() . Omnivorous Bipeds . class Hominidae(ABC): @abstractmethod # how to do it def diet(self): pass @abstractmethod def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h1 = Hominidae() . TypeError Traceback (most recent call last) &lt;ipython-input-131-df612faa022d&gt; in &lt;module&gt; -&gt; 1 h1 = Hominidae() TypeError: Can&#39;t instantiate abstract class Hominidae with abstract methods diet, walk . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Implementing Data Structures",
            "content": "def addition(num1, num2): total = num1 + num2 print(&quot;The sum of %d and %d is %d&quot; %(num1, num2, total)) . addition(10, 4) . The sum of 10 and 4 is 14 . def addition(num1, num2): num_iterations = 0 total = num1 + num2 num_iterations += 1 print(&quot;The sum of %d and %d is %d n total number: %d&quot; %(num1, num2, total, num_iterations)) . addition(50,10) # O(1) operation, number of operations is constant, no matter the input . The sum of 50 and 10 is 60 total number: 1 . def check_prime1(number): num_iterations = 0 for i in range(2, number): num_iterations += 1 if number%i == 0: print(&quot;%d is not a prime number n Total number of iterations = %d&quot; %(number, num_iterations)) return print(&quot;%d is a prime number nTotal number of iterations = %d&quot; %(number, num_iterations)) . check_prime1(10) . 10 is not a prime number Total number of iterations = 1 . check_prime1(50) . 50 is not a prime number Total number of iterations = 1 . check_prime1(1) . 1 is a prime number Total number of iterations = 0 . check_prime1(49) . 49 is not a prime number Total number of iterations = 6 . check_prime1(191) . 191 is a prime number Total number of iterations = 189 . # that takes longer, if the input list gets longer . def print_pairs(number_list): num_iterations = 0 n = len(number_list) for i in range(n): for j in range(n): print(number_list[i], number_list[j]) num_iterations += 1 print(&quot;Total iterations are %d&quot; % num_iterations) . print_pairs([123,67]) . 123 123 123 67 67 123 67 67 Total iterations are 4 . print_pairs([123,67, 25, 79]) . 123 123 123 67 123 25 123 79 67 123 67 67 67 25 67 79 25 123 25 67 25 25 25 79 79 123 79 67 79 25 79 79 Total iterations are 16 . . from queue import Queue olympics = Queue(5) olympics . &lt;queue.Queue at 0x2e919de0708&gt; . olympics.put(&quot;United Statues(USA)&quot;) olympics.put(&quot;Great Britain(GBR)&quot;) . olympics.empty() # O(1) . False . olympics.full() # O(1) . False . olympics.qsize() # O(1) . 2 . olympics.put(&quot;China(CHN)&quot;) olympics.put(&quot;Russia(RUS)&quot;) olympics.put(&quot;Germany(GER)&quot;) . olympics.full() . True . olympics.qsize() . 5 . olympics.get() . &#39;United Statues(USA)&#39; . olympics.qsize() . 4 . olympics.full() . False . stack = [] stack.append(&quot;United States&quot;) stack.append(&quot;Great Britain&quot;) stack.append(&quot;China&quot;) . stack . [&#39;United States&#39;, &#39;Great Britain&#39;, &#39;China&#39;] . stack.pop() . &#39;China&#39; . class Node: def __init__(self, dataval=None, nextval=None): self.dataval = dataval self.nextval = nextval def __repr__(self): return repr(self.dataval) class LinkedList: def __init__(self): self.head = None def __repr__(self): # O(N) nodes = [] curr = self.head while curr: nodes.append(repr(curr)) curr = curr.nextval return &quot;[&quot; + &quot;-&gt;&quot;.join(nodes) + &quot;]&quot; def prepend(self, dataval): # O(1) self.head = Node(dataval=dataval, nextval = self.head) def append(self, dataval): if not self.head: self.head = Node(dataval=dataval) return curr = self.head while curr.nextval: curr = curr.nextval curr.nextval = Node(dataval=dataval) def add_after(self, middle_dataval, dataval): if middle_dataval is None: print(&quot;Data to insert after not specified&quot;) return curr = self.head while curr and curr.dataval != middle_dataval: curr = curr.nextval new_node = Node(dataval = dataval) new_node.nextval = curr.nextval curr.nextval = new_node def find(self, data): curr = self.head while curr and curr.dataval != data: curr = curr.nextval return curr def remove(self, data): curr = self.head prev = None while curr and curr.dataval != data: prev = curr curr = curr.nextval if prev is None: self.head = curr.nextval elif curr: prev.nextval = curr.nextval curr.nextval = None def reverse(self): curr = self.head prev_node = None next_node = None while curr: nextval = curr.nextval curr.nextval = prev_node prev_node = curr curr = nextval self.head = prev_node . numbers = LinkedList() . numbers . [] . numbers.append(&quot;two&quot;) numbers.append(&quot;three&quot;) numbers . [&#39;two&#39;-&gt;&#39;three&#39;] . numbers.prepend(&quot;one&quot;) numbers . [&#39;one&#39;-&gt;&#39;two&#39;-&gt;&#39;three&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Fundamental Data Structures",
            "content": "# make difficult operations possible # occupy less space and still represent the complexity of information and # its interrelationships in an intuitive way # data structures and algorithms go hand-in-hand # A set is extremely fast for membership and containment queries # stacks can be used for undo functionality in applications as well as back functionality # index data structures # hash tables # graphs for relationships # data structures are concrete representations of data from the point of view of an implementor # they specify the actual implementation of the structure in code to meet the expected behavior . Hallo . # Time (# of operations / amount of processing) # Space (make best use of available space, memory and disk space needed) # Network (overall network bandwidth, network speed) # efficient = uses fewer resources along all these axes # using more of the resources that are plenty, and less of those who lack # performance indicates how much of these resources are used by the code # == Performance can be measured in terms of complexity # Complexity is a measure of how resource requirements change as the size of the problem gets larger # The higher the complexity of a overall problem, the lower the performance . 2 . # Read - Write - Assignment - Test # do not worry about the number of operations # be worried how that number changes is based on the input size # that is how performance changes based on input size # focus on the worst case performance # what is the maximum number of basic operations that might have to be performed based on the input # Complexity varies with the algorithm . # Represents the complexity of an algorithm # An algorithm whose complexity does not change with the input size is O(1) # -&gt; the algorithm is said to have constant time complexity # The algorithm is said to have constant time complexity # It takes the same amount of time, even if the input size is doubled, tripled, or increased to any level . # The complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases # Lower order terms and constants do not matter while expressing complexity # O(N^2 + 1000) is equivalent to O(N^2) -&gt; N is assumed very large # O(N^2+N) is equivalent to O(N^2) . . # Header points to the first element # Best way to count is to increment/decrement a counter at every list operation # Adding: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Deleting: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Counting: Iterating -&gt; O(1), Increment/Decrement a permanent Counter -&gt; O(1) # Reversing: O(N) . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # LIFO principle # Insertion and deletion at the same end . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # FIFO principle # Insertion and deletion at opposite ends . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Complex Data Types - Lists and Tuples",
            "content": "empty_list = [] empty_list . list_str=[&quot;Toyota&quot;,&quot;VW&quot;,&quot;BMW&quot;,&quot;Mercedes&quot;] list_str . list_bool=[True, False, False, True] list_bool . list_str[1] . list_str[len(list_str)-1] . list_str[-1] . list_str[0] = &quot;Hyundai&quot; list_str . list_str.append(&quot;Opel&quot;) list_str . list_str += [&#39;Dacia&#39;, &#39;Ford&#39;] list_str . list_str.sort() list_str . list_str.reverse() list_str . list_str.pop() list_str . list_str.count(&quot;Dacia&quot;) . print(list_str) . new_list = list_str.copy() list_str.clear() list_str . del list_str . list_2 = sorted(new_list) # whole new list . any([0]) # greater 0 . any([0, 1]) . all([0,1]) . new_list[0:2] # creates a deep copy . new_list[0:100] . new_list[1:] . new_list[:3] . new_list[:-1] . new_list[-4:-1] . new_list[0:5:2] . &quot;Dacia&quot; in new_list . new_list[::-3] . new_list[100] . new_list.count() .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Complex Data Types - Dictionaries and Sets",
            "content": "empty_dict = {} empty_dict . {} . bike_owners = {&quot;James&quot;:&quot;Ducati Monster 1200&quot;, &quot;Jacob&quot;:&quot;Ducati Scrambler 1100&quot;} bike_owners . {&#39;James&#39;: &#39;Ducati Monster 1200&#39;, &#39;Jacob&#39;: &#39;Ducati Scrambler 1100&#39;} . bike_owners[&quot;Jacob&quot;] . &#39;Ducati Scrambler 1100&#39; . int_dict = {1:45, 2:55, 3:65} int_dict[1] . 45 . int_dict.keys() . dict_keys([1, 2, 3]) . 1 in int_dict.keys() . True . mixed_dict = {False: &quot;Daniel&quot;, &quot;Aria&quot;:[1,2,3], &quot;Jacob&quot;:True} mixed_dict . {False: &#39;Daniel&#39;, &#39;Aria&#39;: [1, 2, 3], &#39;Jacob&#39;: True} . mixed_dict[False] . &#39;Daniel&#39; . int_dict[1] = 78 int_dict . {1: 78, 2: 55, 3: 65} . del int_dict[3] int_dict . {1: 78, 2: 55} . fruits = { &quot;Banana&quot;:[50,60,75,99], &quot;Apple&quot;:[48,86,47,25], &quot;Strawberries&quot;:[70,80,60,65] } print(fruits[&quot;Banana&quot;]) print(fruits[&quot;Banana&quot;][3]) fruits[&quot;Banana&quot;][3]=50 print(fruits[&quot;Banana&quot;][3]) . [50, 60, 75, 99] 99 50 . fruit_qtc_consumed = { &quot;Banana&quot;: {&quot;Fri&quot;:90, &quot;Mo&quot;:80, &quot;Di&quot;:90}, &quot;Apple&quot;:{&quot;Fri&quot;:10, &quot;Mo&quot;:12, &quot;Di&quot;:13}, &quot;Strawberry&quot;:{&quot;Fri&quot;:47, &quot;Mo&quot;:48, &quot;Di&quot;:20}, } print(fruit_qtc_consumed[&quot;Strawberry&quot;]) print(fruit_qtc_consumed[&quot;Strawberry&quot;][&quot;Fri&quot;]) . {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20} 47 . len(fruit_qtc_consumed) . 3 . len(fruit_qtc_consumed.keys()) . 3 . sorted(fruit_qtc_consumed) . [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Strawberry&#39;] . sorted(fruit_qtc_consumed, reverse=True) . [&#39;Strawberry&#39;, &#39;Banana&#39;, &#39;Apple&#39;] . fruit_qtc_consumed.items() . dict_items([(&#39;Banana&#39;, {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}), (&#39;Apple&#39;, {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}), (&#39;Strawberry&#39;, {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20})]) . copy = fruit_qtc_consumed.copy() copy . {&#39;Banana&#39;: {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}, &#39;Apple&#39;: {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}, &#39;Strawberry&#39;: {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20}} . copy.pop(&quot;Banana&quot;) . {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90} . persons1 = {&quot;Ethan&quot;:45,&quot;Monica&quot;:88,&quot;Max&quot;:10} persons2 = {&quot;Ethan&quot;:46,&quot;Claus&quot;:47,&quot;Rainer&quot;:44} print(persons1) persons1.update(persons2) print(persons1) . {&#39;Ethan&#39;: 45, &#39;Monica&#39;: 88, &#39;Max&#39;: 10} {&#39;Ethan&#39;: 46, &#39;Monica&#39;: 88, &#39;Max&#39;: 10, &#39;Claus&#39;: 47, &#39;Rainer&#39;: 44} . persons2.clear() persons2 . {} . del persons2 . set_string = {&quot;Emma&quot;, &quot;Olivia&quot;, &quot;Ava&quot;, &quot;Mia&quot;} set_string . {&#39;Ava&#39;, &#39;Emma&#39;, &#39;Mia&#39;, &#39;Olivia&#39;} . print(set_string) # no intrinsic ordering . {&#39;Ava&#39;, &#39;Mia&#39;, &#39;Emma&#39;, &#39;Olivia&#39;} . empty_set = set() . mixed_set = {&quot;Emmma&quot;, 5, 1.5, True,(1,2,3,4)} #Lists are not allowed . student_set = {&quot;Emma&quot;, &quot;Marc&quot;, &quot;Janine&quot;, &quot;Emma&quot;} student_set # duplicates are eliminated . {&#39;Emma&#39;, &#39;Janine&#39;, &#39;Marc&#39;} . student_set[1] . TypeError Traceback (most recent call last) &lt;ipython-input-35-a8e02497ae7e&gt; in &lt;module&gt; -&gt; 1 student_set[1] 2 3 TypeError: &#39;set&#39; object is not subscriptable . student_set.add(&quot;Felix&quot;) . len(student_set) . 4 . max(student_set) . &#39;Marc&#39; . student_set.remove(&quot;Felix&quot;) student_set.discard(&quot;Felix&quot;) . number1={1,2,3,4,5} number2={4,5,6,7,8} number3={7,8,9,10,11} . number1.union(number2) . {1, 2, 3, 4, 5, 6, 7, 8} . number1.difference(number2) . {1, 2, 3} . number1.isdisjoint(number2) . False . number1.isdisjoint(number3) . True . car_matrix = [[&quot;Hennessey Venom GT&quot;, 1244], [&quot;SSC Ultimate Aero&quot;, 1287], [&quot;Zenvo ST1&quot;, 1100]] car_matrix . [[&#39;Hennessey Venom GT&#39;, 1244], [&#39;SSC Ultimate Aero&#39;, 1287], [&#39;Zenvo ST1&#39;, 1100]] . len(car_matrix) . 3 . len(car_matrix[1]) . 2 . car_matrix[1][0] . &#39;SSC Ultimate Aero&#39; . car_matrix[1] . [&#39;SSC Ultimate Aero&#39;, 1287] . car_matrix[1][0:2] . [&#39;SSC Ultimate Aero&#39;, 1287] . my_list = [&quot;Leo&quot;,18,&quot;Aaron&quot;,15,&quot;Max&quot;,25,&quot;Sofi&quot;,22,&quot;Marques&quot;,2,&quot;Julia&quot;,91,] print(my_list) print(tuple(my_list)) # tuple is immutable . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] (&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91) . my_list1 = [[&quot;Leo&quot;,18],[&quot;Aaron&quot;,48],[&quot;Max&quot;,25],[&quot;Sofi&quot;,22],[&quot;Marques&quot;,2],[&quot;Julia&quot;,91]] tuple(my_list1) . ([&#39;Leo&#39;, 18], [&#39;Aaron&#39;, 48], [&#39;Max&#39;, 25], [&#39;Sofi&#39;, 22], [&#39;Marques&#39;, 2], [&#39;Julia&#39;, 91]) . d_list = dict(my_list1) names = list(d_list) names . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] . d_list2 = dict(my_list1) names2 = list(d_list2.values()) names2 . [18, 48, 25, 22, 2, 91] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Complex Data Types - Deep and Shallow Copies",
            "content": "old_str = &quot;Python&quot; old_str . &#39;Python&#39; . new_str = old_str print(old_str) print(new_str) . Python Python . new_str[2] = &quot;T&quot; . TypeError Traceback (most recent call last) &lt;ipython-input-3-b6e8ff6bdf2e&gt; in &lt;module&gt; -&gt; 1 new_str[2] = &#34;T&#34; TypeError: &#39;str&#39; object does not support item assignment . import copy . first_str = &quot;Will&quot; second_str = copy.copy(first_str) print(first_str) print(second_str) . Will Will . second_str = &quot;Smith&quot; print(first_str) print(second_str) . Will Smith . first_str = &quot;Johnny&quot; second_str = copy.deepcopy(first_str) # the same print(first_str) print(second_str) . Johnny Johnny . second_str = &quot;Depp&quot; print(first_str) print(second_str) . Johnny Depp . names = [&quot;Jan&quot;, &quot;Felix&quot;, &quot;Ralph&quot;] second_names = names . second_names[1] = &quot;Maria&quot; print(names) print(second_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . third_names = copy.copy(names) third_names[0] = &quot;Julia&quot; print(names) print(third_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Julia&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Functions - General",
            "content": "country = &quot;USA&quot; def some_fn(): print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): country = &quot;India&quot; print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): global country country = &quot;Bangladesh&quot; print(country) some_fn() . country . fruits_list = [&quot;Apple&quot;, &quot;Grapes&quot;, &quot;Mango&quot;, &quot;Bananas&quot;] def change_list(fruits_list): fruits_list[0] = &quot;Kiwi&quot; fruits_list = [&quot;Kiwi&quot;] # does nothing on the outside print(&quot;Inside the function: &quot;, fruits_list) change_list(fruits_list) print() print(&quot;Outside the function: &quot;, fruits_list) . help(&quot;modules&quot;) . import math . print(math.pi) . math.e . math.ceil(8.1) . math.floor(8.1) . math.pow(2,4) . math.sqrt(24) . import os . os.getcwd() . os.environ . user = os.environ[&quot;USERNAME&quot;] user . os.environ[&quot;PATH&quot;] . os.listdir() . os.listdir(&quot;.&quot;) . os.path.isdir(os.environ[&quot;PATH&quot;]) . os.path.isfile(os.environ[&quot;PATH&quot;]) . import random . random.random() . random.random() . random.randint(0, 10) . listA = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] random.choice(listA) . import datetime datetime.date.today() . datetime.datetime.now() . def hello(name): print(&quot;Hello!&quot;, name) hello(&quot;Bruce&quot;) . hello . greet = hello . greet(&quot;Max&quot;) . calculate_length = len calculate_length(&quot;SomeString&quot;) . calculate_length == len . import math def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) def diameter_circle_fn(r): pass calculate(10, fn=diameter_circle_fn) . def area_rectangle_fn(length, breadth): return length * breadth def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) calculate(20, 40, fn=area_rectangle_fn) . def square(x): return x * x . result = square(5) result . square . sq = square . result = sq(12) result . cube_of = lambda x: x * x * x result = cube_of(3) result . cube_of . add = lambda x, y: x + y . result = add(5, 10) result . (lambda x: x + 2)(10) . (lambda x:x * 10)(22) . def check_if_even(x): assert x % 2 == 0 . check_if_even(2) . check_if_even(3) . even_check_lambda = lambda x : assert x % 2 == 0 . total_score = lambda math, physics, chemistry, biology=50: math+physics+chemistry+biology . total_score(math=50, physics=10, chemistry=23) . (lambda **num_dictionary: sum(num_dictionary.values()))(a=23, b=34, c=45) . num_list = [1,5,6,7,11,78,99,34,105,214] . filter(lambda x: x &gt; 10, num_list) . greater_than_10_list = list(filter(lambda x: x &gt; 10, num_list)) greater_than_10_list . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Functions - Advanced",
            "content": "def hello(name): print(&quot;Hello&quot;, name) hello(name) #hello(&quot;Ron&quot;) . import sys sys.getrecursionlimit() . 3000 . def increment(num): print(num, end = &quot; &quot;) increment(num + 1) return #increment(1) . def decrement(num): while num &gt; 0: print(num) num = num - 1 decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def decrement(num): if num == 0: return print(num) decrement(num - 1) decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def generator(): print(&quot;One!&quot;) yield 1 # control execution flow print(&quot;Two!&quot;) yield 2 print(&quot;Three!&quot;) yield 3 g = generator() # no code execution g . &lt;generator object generator at 0x000001A6BE9FBCC8&gt; . next(g) # execute g until the first yield statement . One! . 1 . next(g) # second yield statement . Two! . 2 . next(g) # until third statement . Three! . 3 . next(g) . StopIteration Traceback (most recent call last) &lt;ipython-input-20-e734f8aca5ac&gt; in &lt;module&gt; -&gt; 1 next(g) StopIteration: . g2 = generator() g . next(g2) . def generator(): print(&quot;One!&quot;) n = 1 yield n # control execution flow print(&quot;Two!&quot;) n += 1 yield n print(&quot;Three!&quot;) n += 1 yield n g3 = generator() . next(g3) . next(g3) . def generate_even_numbers(limit): for i in range(0, limit, 2): yield i . g = generate_even_numbers(7) . next(g) . next(g) . next(g) . next(g) . next(g) . g2 = generate_even_numbers(20) g2_list = list(g2) . g2_list . def generate_powers_of_two(): num = 0 while True: num = num + 1 yield 2 ** num . g = generate_powers_of_two() . next(g) . next(g) . def nested_hello_fn(): def hello(): print(&quot;Hello Cathy!&quot;) hello() . nested_hello_fn() . hello() . def get_hello_fn(): # every closure has its own local state (do not share local variables) def hello(): print(&quot;Hello Cathy!&quot;) return hello . hello_fn = get_hello_fn() . hello_fn() . def print_message(): print(&quot;Yohoo! Decorators are cool!&quot;) . print_message() . import random def highlight(): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) print_message() print(annotate * 50) highlight() . def make_highlighted(func): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) func() print(annotate * 50) make_highlighted(print_message) . @make_highlighted # that&#39;S how they are really used def print_a_message(): print(&quot;Now you&#39;ll see how decorators are used&quot;) print_a_message . def plus_highlight(func): def highlight(): print(&quot;+&quot;*50) func() print(&quot;+&quot;*50) return highlight def asterisk_highlight(func): def highlight(): print(&quot;*&quot;*50) func() print(&quot;*&quot;*50) return highlight @plus_highlight @asterisk_highlight def hello(): print(&quot;hello!&quot;) hello() . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Introducing fastpages",
            "content": ". We are very pleased to announce the immediate availability of fastpages. fastpages is a platform which allows you to create and host a blog for free, with no ads and many useful features, such as: . Create posts containing code, outputs of code (which can be interactive), formatted text, etc directly from Jupyter Notebooks; for instance see this great example post from Scott Hawley. Notebook posts support features such as: Interactive visualizations made with Altair remain interactive. | Hide or show cell input and output. | Collapsable code cells that are either open or closed by default. | Define the Title, Summary and other metadata via a special markdown cells | Ability to add links to Colab and GitHub automatically. | . | Create posts, including formatting and images, directly from Microsoft Word documents. | Create and edit Markdown posts entirely online using GitHub&#39;s built-in markdown editor. | Embed Twitter cards and YouTube videos. | Categorization of blog posts by user-supplied tags for discoverability. | ... and much more | . fastpages relies on Github pages for hosting, and Github Actions to automate the creation of your blog. The setup takes around three minutes, and does not require any technical knowledge or expertise. Due to built-in automation of fastpages, you don&#39;t have to fuss with conversion scripts. All you have to do is save your Jupyter notebook, Word document or markdown file into a specified directory and the rest happens automatically. Infact, this blog post is written in a Jupyter notebook, which you can see with the &quot;View on GitHub&quot; link above. . fast.ai have previously released a similar project called fast_template, which is even easier to set up, but does not support automatic creation of posts from Microsoft Word or Jupyter notebooks, including many of the features outlined above. . Because fastpages is more flexible and extensible, we recommend using it where possible. fast_template may be a better option for getting folks blogging who have no technical expertise at all, and will only be creating posts using Github&#39;s integrated online editor. . Setting Up Fastpages . The setup process of fastpages is automated with GitHub Actions, too! Upon creating a repo from the fastpages template, a pull request will automatically be opened (after ~ 30 seconds) configuring your blog so it can start working. The automated pull request will greet you with instructions like this: . . All you have to do is follow these instructions (in the PR you receive) and your new blogging site will be up and running! . Jupyter Notebooks &amp; Fastpages . In this post, we will cover special features that fastpages provides for Jupyter notebooks. You can also write your blog posts with Word documents or markdown in fastpages, which contain many, but not all the same features. . Options via FrontMatter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . All of the above settings are enabled in this post, so you can see what they look like! . the summary field (preceeded by &gt;) will be displayed under your title, and will also be used by social media to display as the description of your page. | toc: setting this to true will automatically generate a table of contents | badges: setting this to true will display Google Colab and GitHub links on your blog post. | comments: setting this to true will enable comments. See these instructions for more details. | author this will display the authors names. | categories will allow your post to be categorized on a &quot;Tags&quot; page, where readers can browse your post by categories. | . Markdown front matter is formatted similarly to notebooks. The differences between the two can be viewed on the fastpages README. . Code Folding . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . If you want to completely hide cells (not just collapse them), read these instructions. . Interactive Charts With Altair . Interactive visualizations made with Altair remain interactive! . We leave this below cell unhidden so you can enjoy a preview of syntax highlighting in fastpages, which uses the Dracula theme. . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;IMDB_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget IMDB_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | 6.1 | . 1 First Love, Last Rites | 10876.0 | 300000.0 | 6.9 | . 2 I Married a Strange Person | 203134.0 | 250000.0 | 6.8 | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | NaN | . 4 Slam | 1087521.0 | 1000000.0 | 3.4 | . Other Features . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Images w/Captions . You can include markdown images with captions like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Of course, the caption is optional. . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . More Examples . This tutorial contains more examples of what you can do with notebooks. . How fastpages Converts Notebooks to Blog Posts . fastpages uses nbdev to power the conversion process of Jupyter Notebooks to blog posts. When you save a notebook into the /_notebooks folder of your repository, GitHub Actions applies nbdev against those notebooks automatically. The same process occurs when you save Word documents or markdown files into the _word or _posts directory, respectively. . We will discuss how GitHub Actions work in a follow up blog post. . Resources &amp; Next Steps . We highly encourage you to start blogging with fastpages! Some resources that may be helpful: . fastpages repo - this is where you can go to create your own fastpages blog! | Fastai forums - nbdev &amp; blogging category. You can ask questions about fastpages here, as well as suggest new features. | nbdev: this project powers the conversion of Jupyter notebooks to blog posts. | . If you end up writing a blog post using fastpages, please let us know on Twitter: @jeremyphoward, @HamelHusain. .",
            "url": "https://elydora.github.io/DataScienceBlog/fastpages/jupyter/2020/02/21/ref-intro.html",
            "relUrl": "/fastpages/jupyter/2020/02/21/ref-intro.html",
            "date": " • Feb 21, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://elydora.github.io/DataScienceBlog/jupyter/2020/02/20/ref-notebooks.html",
            "relUrl": "/jupyter/2020/02/20/ref-notebooks.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://elydora.github.io/DataScienceBlog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "SAP developer by day, Python developer by night. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://elydora.github.io/DataScienceBlog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://elydora.github.io/DataScienceBlog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}