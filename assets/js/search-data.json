{
  
    
        "post0": {
            "title": "Web Scraping Lab",
            "content": "Web Scraping Lab . Estimated time needed: 30 minutes . Objectives . After completing this lab you will be able to: . Table of Contents . Beautiful Soup Object Tag | Children, Parents, and Siblings | HTML Attributes | Navigable String | . | . Filter find All | find | HTML Attributes | Navigable String | . | . Downloading And Scraping The Contents Of A Web | . Estimated time needed: 25 min . . For this lab, we are going to be using Python and several Python libraries. Some of these libraries might be installed in your lab environment or in SN Labs. Others may need to be installed by you. The cells below will install these libraries when executed. . !pip install bs4 #!pip install requests . Import the required modules and functions . from bs4 import BeautifulSoup # this module helps in web scrapping. import requests # this module helps us to download a web page . Beautiful Soup Objects . Beautiful Soup is a Python library for pulling data out of HTML and XML files, we will focus on HTML files. This is accomplished by representing the HTML as a set of objects with methods used to parse the HTML. We can navigate the HTML as a tree and/or filter out what we are looking for. . Consider the following HTML: . %%html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;&lt;b id=&#39;boldest&#39;&gt;Lebron James&lt;/b&gt;&lt;/h3&gt; &lt;p&gt; Salary: $ 92,000,000 &lt;/p&gt; &lt;h3&gt; Stephen Curry&lt;/h3&gt; &lt;p&gt; Salary: $85,000, 000 &lt;/p&gt; &lt;h3&gt; Kevin Durant &lt;/h3&gt; &lt;p&gt; Salary: $73,200, 000&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; . &lt;!DOCTYPE html&gt; Page Title . Lebron James . Salary: $ 92,000,000 . Stephen Curry . Salary: $85,000, 000 . Kevin Durant . Salary: $73,200, 000 . . We can store it as a string in the variable HTML: . html=&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;b id=&#39;boldest&#39;&gt;Lebron James&lt;/b&gt;&lt;/h3&gt;&lt;p&gt; Salary: $ 92,000,000 &lt;/p&gt;&lt;h3&gt; Stephen Curry&lt;/h3&gt;&lt;p&gt; Salary: $85,000, 000 &lt;/p&gt;&lt;h3&gt; Kevin Durant &lt;/h3&gt;&lt;p&gt; Salary: $73,200, 000&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot; . To parse a document, pass it into the BeautifulSoup constructor, the BeautifulSoup object, which represents the document as a nested data structure: . soup = BeautifulSoup(html, &#39;html5lib&#39;) . First, the document is converted to Unicode, (similar to ASCII), and HTML entities are converted to Unicode characters. Beautiful Soup transforms a complex HTML document into a complex tree of Python objects. The BeautifulSoup object can create other types of objects. In this lab, we will cover BeautifulSoup and Tag objects that for the purposes of this lab are identical, and NavigableString objects. . We can use the method prettify() to display the HTML in the nested structure: . print(soup.prettify()) . Tags . Let&#39;s say we want the title of the page and the name of the top paid player we can use the Tag. The Tag object corresponds to an HTML tag in the original document, for example, the tag title. . tag_object=soup.title print(&quot;tag object:&quot;,tag_object) . we can see the tag type bs4.element.Tag . print(&quot;tag object type:&quot;,type(tag_object)) . If there is more than one Tag with the same name, the first element with that Tag name is called, this corresponds to the most paid player: . tag_object=soup.h3 tag_object . Enclosed in the bold attribute b, it helps to use the tree representation. We can navigate down the tree using the child attribute to get the name. . Children, Parents, and Siblings . As stated above the Tag object is a tree of objects we can access the child of the tag or navigate down the branch as follows: . tag_child =tag_object.b tag_child . You can access the parent with the parent . parent_tag=tag_child.parent parent_tag . this is identical to . tag_object . tag_object parent is the body element. . tag_object.parent . tag_object sibling is the paragraph element . sibling_1=tag_object.next_sibling sibling_1 . sibling_2 is the header element which is also a sibling of both sibling_1 and tag_object . sibling_2=sibling_1.next_sibling sibling_2 . Exercise: next_sibling . Using the object sibling_2 and the method next_sibling to find the salary of Stephen Curry: . Click here for the solution sibling_2.next_sibling HTML Attributes . If the tag has attributes, the tag id=&quot;boldest&quot; has an attribute id whose value is boldest. You can access a tag’s attributes by treating the tag like a dictionary: . tag_child[&#39;id&#39;] . You can access that dictionary directly as attrs: . tag_child.attrs . You can also work with Multi-valued attribute check out [1] for more. . We can also obtain the content if the attribute of the tag using the Python get() method. . tag_child.get(&#39;id&#39;) . Navigable String . A string corresponds to a bit of text or content within a tag. Beautiful Soup uses the NavigableString class to contain this text. In our HTML we can obtain the name of the first player by extracting the sting of the Tag object tag_child as follows: . tag_string=tag_child.string tag_string . we can verify the type is Navigable String . type(tag_string) . A NavigableString is just like a Python string or Unicode string, to be more precise. The main difference is that it also supports some BeautifulSoup features. We can covert it to sting object in Python: . unicode_string = str(tag_string) unicode_string . Filter . Filters allow you to find complex patterns, the simplest filter is a string. In this section we will pass a string to a different filter method and Beautiful Soup will perform a match against that exact string. Consider the following HTML of rocket launchs: . %%html &lt;table&gt; &lt;tr&gt; &lt;td id=&#39;flight&#39; &gt;Flight No&lt;/td&gt; &lt;td&gt;Launch site&lt;/td&gt; &lt;td&gt;Payload mass&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Florida&#39;&gt;Florida&lt;/a&gt;&lt;/td&gt; &lt;td&gt;300 kg&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Texas&#39;&gt;Texas&lt;/a&gt;&lt;/td&gt; &lt;td&gt;94 kg&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Florida&#39;&gt;Florida&lt;a&gt; &lt;/td&gt; &lt;td&gt;80 kg&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; . Flight No | Launch site | Payload mass | . 1 | Florida | 300 kg | . 2 | Texas | 94 kg | . 3 | Florida &lt;/td&gt; 80 kg | &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; We can store it as a string in the variable table: . table=&quot;&lt;table&gt;&lt;tr&gt;&lt;td id=&#39;flight&#39;&gt;Flight No&lt;/td&gt;&lt;td&gt;Launch site&lt;/td&gt; &lt;td&gt;Payload mass&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Florida&#39;&gt;Florida&lt;a&gt;&lt;/td&gt;&lt;td&gt;300 kg&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Texas&#39;&gt;Texas&lt;/a&gt;&lt;/td&gt;&lt;td&gt;94 kg&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&lt;a href=&#39;https://en.wikipedia.org/wiki/Florida&#39;&gt;Florida&lt;a&gt; &lt;/td&gt;&lt;td&gt;80 kg&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot; . table_bs = BeautifulSoup(table, &#39;html5lib&#39;) . find All . The find_all() method looks through a tag’s descendants and retrieves all descendants that match your filters. . The Method signature for find_all(name, attrs, recursive, string, limit, **kwargs)&lt;c/ode&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Name . When we set the name parameter to a tag name, the method will extract all the tags with that name and its children. . table_rows=table_bs.find_all(&#39;tr&#39;) table_rows . The result is a Python Iterable just like a list, each element is a tag object: . first_row =table_rows[0] first_row . The type is tag . print(type(first_row)) . we can obtain the child . first_row.td . If we iterate through the list, each element corresponds to a row in the table: . for i,row in enumerate(table_rows): print(&quot;row&quot;,i,&quot;is&quot;,row) . As row is a cell object, we can apply the method find_all to it and extract table cells in the object cells using the tag td, this is all the children with the name td. The result is a list, each element corresponds to a cell and is a Tag object, we can iterate through this list as well. We can extract the content using the string attribute. . for i,row in enumerate(table_rows): print(&quot;row&quot;,i) cells=row.find_all(&#39;td&#39;) for j,cell in enumerate(cells): print(&#39;colunm&#39;,j,&quot;cell&quot;,cell) . If we use a list we can match against any item in that list. . list_input=table_bs .find_all(name=[&quot;tr&quot;, &quot;td&quot;]) list_input . Attributes . If the argument is not recognized it will be turned into a filter on the tag’s attributes. For example the id argument, Beautiful Soup will filter against each tag’s id attribute. For example, the first td elements have a value of id of flight, therefore we can filter based on that id value. . table_bs.find_all(id=&quot;flight&quot;) . We can find all the elements that have links to the Florida Wikipedia page: . list_input=table_bs.find_all(href=&quot;https://en.wikipedia.org/wiki/Florida&quot;) list_input . If we set the href attribute to True, regardless of what the value is, the code finds all tags with href value: . table_bs.find_all(href=True) . There are other methods for dealing with attributes and other related methods; Check out the following link . Exercise: find_all . Using the logic above, find all the elements without href value . Click here for the solution table_bs.find_all(href=False) Using the soup object soup, find the element with the id attribute content set to &quot;boldest&quot;. . Click here for the solution soup.find_all(id=&quot;boldest&quot;) string . With string you can search for strings instead of tags, where we find all the elments with Florida: . table_bs.find_all(string=&quot;Florida&quot;) . find . The find_all() method scans the entire document looking for results, it’s if you are looking for one element you can use the find() method to find the first element in the document. Consider the following two table: . %%html &lt;h3&gt;Rocket Launch &lt;/h3&gt; &lt;p&gt; &lt;table class=&#39;rocket&#39;&gt; &lt;tr&gt; &lt;td&gt;Flight No&lt;/td&gt; &lt;td&gt;Launch site&lt;/td&gt; &lt;td&gt;Payload mass&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Florida&lt;/td&gt; &lt;td&gt;300 kg&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;Texas&lt;/td&gt; &lt;td&gt;94 kg&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;Florida &lt;/td&gt; &lt;td&gt;80 kg&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/p&gt; &lt;p&gt; &lt;h3&gt;Pizza Party &lt;/h3&gt; &lt;table class=&#39;pizza&#39;&gt; &lt;tr&gt; &lt;td&gt;Pizza Place&lt;/td&gt; &lt;td&gt;Orders&lt;/td&gt; &lt;td&gt;Slices &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Domino&#39;s Pizza&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Little Caesars&lt;/td&gt; &lt;td&gt;12&lt;/td&gt; &lt;td &gt;144 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Papa John&#39;s &lt;/td&gt; &lt;td&gt;15 &lt;/td&gt; &lt;td&gt;165&lt;/td&gt; &lt;/tr&gt; . Rocket Launch . Flight No | Launch site | Payload mass | . 1 | Florida | 300 kg | . 2 | Texas | 94 kg | . 3 | Florida | 80 kg | . . Pizza Party . Pizza Place | Orders | Slices | . Domino&#39;s Pizza | 10 | 100 | . Little Caesars | 12 | 144 | . Papa John&#39;s | 15 | 165 | . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; We store the HTML as a Python string and assign two_tables: . two_tables=&quot;&lt;h3&gt;Rocket Launch &lt;/h3&gt;&lt;p&gt;&lt;table class=&#39;rocket&#39;&gt;&lt;tr&gt;&lt;td&gt;Flight No&lt;/td&gt;&lt;td&gt;Launch site&lt;/td&gt; &lt;td&gt;Payload mass&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Florida&lt;/td&gt;&lt;td&gt;300 kg&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Texas&lt;/td&gt;&lt;td&gt;94 kg&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;Florida &lt;/td&gt;&lt;td&gt;80 kg&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;&lt;p&gt;&lt;h3&gt;Pizza Party &lt;/h3&gt;&lt;table class=&#39;pizza&#39;&gt;&lt;tr&gt;&lt;td&gt;Pizza Place&lt;/td&gt;&lt;td&gt;Orders&lt;/td&gt; &lt;td&gt;Slices &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Domino&#39;s Pizza&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Little Caesars&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td &gt;144 &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Papa John&#39;s &lt;/td&gt;&lt;td&gt;15 &lt;/td&gt;&lt;td&gt;165&lt;/td&gt;&lt;/tr&gt;&quot; . We create a BeautifulSoup object two_tables_bs . two_tables_bs= BeautifulSoup(two_tables, &#39;html.parser&#39;) . We can find the first table using the tag name table . two_tables_bs.find(&quot;table&quot;) . We can filter on the class attribute to find the second table, but because class is a keyword in Python, we add an underscore. . two_tables_bs.find(&quot;table&quot;,class_=&#39;pizza&#39;) . Downloading And Scraping The Contents Of A Web Page . We Download the contents of the web page: . url = &quot;http://www.ibm.com&quot; . We use get to download the contents of the webpage in text format and store in a variable called data: . data = requests.get(url).text . We create a BeautifulSoup object using the BeautifulSoup constructor . soup = BeautifulSoup(data,&quot;html5lib&quot;) # create a soup object using the variable &#39;data&#39; . Scrape all links . for link in soup.find_all(&#39;a&#39;,href=True): # in html anchor/link is represented by the tag &lt;a&gt; print(link.get(&#39;href&#39;)) . Scrape all images Tags . for link in soup.find_all(&#39;img&#39;):# in html image is represented by the tag &lt;img&gt; print(link) print(link.get(&#39;src&#39;)) . Scrape data from HTML tables . url = &quot;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/labs/datasets/HTMLColorCodes.html&quot; . Before proceeding to scrape a web site, you need to examine the contents, and the way data is organized on the website. Open the above url in your browser and check how many rows and columns are there in the color table. . data = requests.get(url).text . soup = BeautifulSoup(data,&quot;html5lib&quot;) . table = soup.find(&#39;table&#39;) # in html table is represented by the tag &lt;table&gt; . for row in table.find_all(&#39;tr&#39;): # in html table row is represented by the tag &lt;tr&gt; # Get all columns in each row. cols = row.find_all(&#39;td&#39;) # in html a column is represented by the tag &lt;td&gt; color_name = cols[2].string # store the value in column 3 as color_name color_code = cols[3].string # store the value in column 4 as color_code print(&quot;{}&gt;{}&quot;.format(color_name,color_code)) . Scrape data from HTML tables into a DataFrame using BeautifulSoup and Pandas . import pandas as pd . url = &quot;https://en.wikipedia.org/wiki/World_population&quot; . Before proceeding to scrape a web site, you need to examine the contents, and the way data is organized on the website. Open the above url in your browser and check the tables on the webpage. . data = requests.get(url).text . soup = BeautifulSoup(data,&quot;html5lib&quot;) . tables = soup.find_all(&#39;table&#39;) # in html table is represented by the tag &lt;table&gt; . len(tables) . Assume that we are looking for the 10 most densly populated countries table, we can look through the tables list and find the right one we are look for based on the data in each table or we can search for the table name if it is in the table but this option might not always work. . for index,table in enumerate(tables): if (&quot;10 most densely populated countries&quot; in str(table)): table_index = index print(table_index) . See if you can locate the table name of the table, 10 most densly populated countries, below. . print(tables[table_index].prettify()) . population_data = pd.DataFrame(columns=[&quot;Rank&quot;, &quot;Country&quot;, &quot;Population&quot;, &quot;Area&quot;, &quot;Density&quot;]) for row in tables[table_index].tbody.find_all(&quot;tr&quot;): col = row.find_all(&quot;td&quot;) if (col != []): rank = col[0].text country = col[1].text population = col[2].text.strip() area = col[3].text.strip() density = col[4].text.strip() population_data = population_data.append({&quot;Rank&quot;:rank, &quot;Country&quot;:country, &quot;Population&quot;:population, &quot;Area&quot;:area, &quot;Density&quot;:density}, ignore_index=True) population_data . Scrape data from HTML tables into a DataFrame using BeautifulSoup and read_html . Using the same url, data, soup, and tables object as in the last section we can use the read_html function to create a DataFrame. . Remember the table we need is located in tables[table_index] . We can now use the pandas function read_html and give it the string version of the table as well as the flavor which is the parsing engine bs4. . pd.read_html(str(tables[5]), flavor=&#39;bs4&#39;) . The function read_html always returns a list of DataFrames so we must pick the one we want out of the list. . population_data_read_html = pd.read_html(str(tables[5]), flavor=&#39;bs4&#39;)[0] population_data_read_html . Scrape data from HTML tables into a DataFrame using read_html . We can also use the read_html function to directly get DataFrames from a url. . dataframe_list = pd.read_html(url, flavor=&#39;bs4&#39;) . We can see there are 25 DataFrames just like when we used find_all on the soup object. . len(dataframe_list) . Finally we can pick the DataFrame we need out of the list. . dataframe_list[5] . We can also use the match parameter to select the specific table we want. If the table contains a string matching the text it will be read. . pd.read_html(url, match=&quot;10 most densely populated countries&quot;, flavor=&#39;bs4&#39;)[0] . Authors . Ramesh Sannareddy . Other Contributors . Rav Ahuja . Change Log . Date (YYYY-MM-DD) Version Changed By Change Description . 2020-10-17 | 0.1 | Joseph Santarcangelo Created initial version of the lab | | . Copyright © 2020 IBM Corporation. This notebook and its source code are released under the terms of the MIT License. . &lt;/div&gt; . | .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/2021/03/07/webscraping.html",
            "relUrl": "/ibm/data_science/2021/03/07/webscraping.html",
            "date": " • Mar 7, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Report02",
            "content": "Fwfwfwfw . Fwfwfw . Fwfw . Video provides a powerful way to help you prove your point. When you click Online Video, you can paste in the embed code for the video you want to add. You can also type a keyword to search online for the video that best fits your document. . To make your document look professionally produced, Word provides header, footer, cover page, and text box designs that complement each other. For example, you can add a matching cover page, header, and sidebar. Click Insert and then choose the elements you want from the different galleries. . Themes and styles also help keep your document coordinated. When you click Design and choose a new Theme, the pictures, charts, and SmartArt graphics change to match your new theme. When you apply styles, your headings change to match the new theme. . Save time in Word with new buttons that show up where you need them. To change the way a picture fits in your document, click it and a button for layout options appears next to it. When you work on a table, click where you want to add a row or a column, and then click the plus sign. . Reading is easier, too, in the new Reading view. You can collapse parts of the document and focus on the text you want. If you need to stop reading before you reach the end, Word remembers where you left off - even on another device. . Video provides a powerful way to help you prove your point. When you click Online Video, you can paste in the embed code for the video you want to add. You can also type a keyword to search online for the video that best fits your document. . To make your document look professionally produced, Word provides header, footer, cover page, and text box designs that complement each other. For example, you can add a matching cover page, header, and sidebar. Click Insert and then choose the elements you want from the different galleries. . Themes and styles also help keep your document coordinated. When you click Design and choose a new Theme, the pictures, charts, and SmartArt graphics change to match your new theme. When you apply styles, your headings change to match the new theme. . Save time in Word with new buttons that show up where you need them. To change the way a picture fits in your document, click it and a button for layout options appears next to it. When you work on a table, click where you want to add a row or a column, and then click the plus sign. . Reading is easier, too, in the new Reading view. You can collapse parts of the document and focus on the text you want. If you need to stop reading before you reach the end, Word remembers where you left off - even on another device. .",
            "url": "https://elydora.github.io/DataScienceBlog/2021/03/05/Report02.html",
            "relUrl": "/2021/03/05/Report02.html",
            "date": " • Mar 5, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Report01",
            "content": ". | . | . March 7 . COMPANY NAME . Authored by: Your Name . | . . Title Heading . Subtitle Text Here . To get started right away, just tap any placeholder text (such as this) and start typing to replace it with your own. . Want to insert a picture from your files or add a shape, text box, or table? You got it! On the Insert tab of the ribbon, just tap the option you need. . | . | . To get started right away, just tap any placeholder text (such as this) and start typing to replace it with your own. . Want to insert a picture from your files or add a shape, text box, or table? You got it! On the Insert tab of the ribbon, just tap the option you need. . | .",
            "url": "https://elydora.github.io/DataScienceBlog/2021/03/05/Report01.html",
            "relUrl": "/2021/03/05/Report01.html",
            "date": " • Mar 5, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Creational Design Patterns",
            "content": "# a class of which only a single instance can exist # Ensure a class is instantiated only once, and provide a global point of access to it # When: # - no clear owner of the object, i. e. a global object (e. g. logger) # - when you want to use lazy instantiation # - when you need a single global way to access the object # python offers a global object pattern . class Logger: __instance = None def __init__(self): raise RuntimeError(&#39;Call get_instance() instead&#39;) @classmethod def get_instance(cls): if cls.__instance is None : print(&#39;No instance exists, creating a new one&#39;) cls.__instance = cls.__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger1 = Logger.get_instance() logger1 . logger2 = Logger.get_instance() . logger2 . # new is always called first -&gt; it creates the instance, cls is reference to not yet existing instance # init is used to initialize the existing instance -&gt; self is a reference to the instance class PythonicLogger: __instance = None def __init__(self): print(&#39;Object initialized&#39;) # put your custom code here # is called every time - could be expensive def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(PythonicLogger, cls).__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger3 = PythonicLogger() logger3 . logger4 = PythonicLogger() logger4 . class SuperLogger: __instance = None def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(SuperLogger, cls).__new__(cls) # Place all initialization code here else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger5 = SuperLogger() logger5 . logger6 = SuperLogger() logger6 . logger5 == logger6 . # Global Objects which expose methods import logger . logger.INFO . logger.WARNING . file_logger = logger.FILE_LOGGER file_logger.log(&quot;logging message&quot;) . # Separate the creation of objects from their use # Class creation or Object creation # Class-creation patterns use inheritance # Object-creation patterns use delegation # Factory method is specified in base class, implemented in derived classes # Creates an instance of several derived classes # Define an interface for creating an object, but let subclasses decide which class to instantiate # Used to postpone instantiation - responsibility passes from base class to derived classes # Factory method -&gt; create an instance of any of many derived classes # Abstract F. pattern -&gt; create an instance of any one of many families of derived classes # Abstract Factory: create instances of several families of classes # encapsulate platform dependencies # Use case: Working with Oracle or MS-SQL databases -&gt; each represents a family of classes # Microsoft Factory | Oracle Factory . class Product: def __init__(self, name, price): self.__name = name self.__price = price def get_price(self): return self.__price . class MacBookAir(Product): def __init__(self, memory, os): Product.__init__(self, &#39;MacBookAir&#39;, 1031) self.__memory = memory self.__os = os class AppleIPad(Product): def __init__(self, generation): Product.__init__(self, &#39;AppleIPad&#39;, 529) self.__generation = generation class AppleIWatch(Product): def __init__(self): Product.__init__(self, &#39;AppleIWatch&#39;, 264) . class ProductFactory(): @staticmethod def create(item_name, *args): if item_name == &#39;MacBookAir&#39;: return MacBookAir(*args) elif item_name == &#39;AppleIPad&#39;: return AppleIPad(*args) elif item_name == &#39;AppleIWatch&#39;: return AppleIWatch(*args) . air = ProductFactory.create(&#39;MacBookAir&#39;, &#39;16GB&#39;, &#39;Sierra&#39;) air.__dict__ . ipad = ProductFactory.create(&#39;AppleIPad&#39;, &#39;2nd&#39;) ipad.__dict__ . iwatch = ProductFactory.create(&#39;AppleIWatch&#39;) iwatch.__dict__ . https://realpython.com/factory-method-python/ . import json import xml.etree.ElementTree as et class Movie: def __init__(self, movie_id, name, director): self.movie_id = movie_id self.name = name self.director = director . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) elif fmt == &#39;XML&#39;: movie_info = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_info, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_info, &#39;director&#39;) director.text = movie.director return et.tostring(movie_info, encoding=&#39;unicode&#39;) else: raise ValueError(fmt) . movie = Movie(&#39;578&#39;, &#39;Avengers:End Game&#39;, &#39;Russo brothers&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . serializer.serialize(movie, &#39;YAML&#39;) . Complex logical code uses if/elif/else structures to change the behavior of an application. Using if/elif/else conditional structures makes the code harder to read, harder to understand, and harder to maintain. . When a new format is introduced: The method will have to change to implement the serialization to that format. . | When the movie object changes: Adding or removing properties to the Song class will require the implementation to change in order to accommodate the new structure. . | When the string representation for a format changes (plain JSON vs JSON API): The .serialize() method will have to change if the desired string representation for a format changes because the representation is hard-coded in the .serialize() method implementation. . | . Refactoring Code Into the Desired Interface . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: return self._serialize_to_json(movie) elif fmt == &#39;XML&#39;: return self._serialize_to_xml(movie) else: raise ValueError(format) def _serialize_to_json(self, movie): movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) def _serialize_to_xml(self, movie): movie_element = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_element, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_element, &#39;director&#39;) director.text = movie.director return et.tostring(movie_element, encoding=&#39;unicode&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . . Provide an interface for creating families of related or dependent objects without specifying their concrete classes. . An abstract factory is a factory that returns factories.A normal factory can be used to create sets of related objects. An abstract factory returns factories. Thus, an abstract factory is used to return factories that can be used to create sets of related objects. . When the system needs to be independent of how its object are created, composed, and represented. | When the family of related objects has to be used together, then this constraint needs to be enforced. | When you want to provide a library of objects that does not show implementations and only reveals interfaces. | When the system needs to be configured with one of a multiple family of objects. | . import abc . create an interface for Toys and color . class Toy(metaclass=abc.ABCMeta): @abc.abstractmethod def show(self): pass class Color(metaclass=abc.ABCMeta): @abc.abstractmethod def show_color(self): pass . class Car(Toy): def show(self): print(&quot;Remote controlled car&quot;) class ActionFigure(Toy): def show(self): print(&quot;Captain America action figure&quot;) class ConstructionToy(Toy): def show(self): print(&quot;Lego&quot;) . class Red(Color): def show_color(self): print(&quot;red&quot;) class Green(Color): def show_color(self): print(&quot;green&quot;) class Blue(Color): def show_color(self): print(&quot;blue&quot;) . car = Car() red = Red() red.show_color(), car.show() . red Remote controlled car . (None, None) . lego = ConstructionToy() green = Green() green.show_color(), lego.show() . green Lego . (None, None) . class AbstractFactory(metaclass=abc.ABCMeta): @abc.abstractmethod def get_color(self): pass @abc.abstractmethod def get_toy(self): pass . Create concrete classes implementing the same interface. . create Factory classes extending AbstractFactory . class ColorfulToysFactory(AbstractFactory): def get_toy(self, toy_type): if toy_type == None: return None if toy_type == &quot;car&quot;: return Car() elif toy_type == &quot;action figure&quot;: return ActionFigure() elif toy_type == &quot;construction toy&quot;: return ConstructionToy() return None def get_color(self, color_type): if color_type == None: return None if color_type == &quot;red&quot;: return Red() elif color_type == &quot;green&quot;: return Green() elif color_type == &quot;blue&quot;: return Blue() return None . RED_CAR = &#39;red_car&#39; BLUE_LEGO = &#39;blue_lego&#39; GREEN_ACTION_FIGURE = &#39;green_action_figure&#39; . Use the FactoryProducer to get AbstractFactory in order to get factories of concrete classes by passing an information such as type . class ColorfulToysProducer: __colorful_toys_factory = ColorfulToysFactory() @classmethod def get_toy_and_color(cls, choice): toy = None color = None if choice == RED_CAR: toy = cls.__colorful_toys_factory.get_toy(&#39;car&#39;) color = cls.__colorful_toys_factory.get_color(&#39;red&#39;) elif choice == BLUE_LEGO: toy = cls.__colorful_toys_factory.get_toy(&#39;construction toy&#39;) color = cls.__colorful_toys_factory.get_color(&#39;blue&#39;) elif choice == GREEN_ACTION_FIGURE: toy = cls.__colorful_toys_factory.get_toy(&#39;action figure&#39;) color = cls.__colorful_toys_factory.get_color(&#39;green&#39;) return toy, color . toy, color = ColorfulToysProducer.get_toy_and_color(RED_CAR) toy, color . (&lt;__main__.Car at 0x253feb8a748&gt;, &lt;__main__.Red at 0x253ff224fc8&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(BLUE_LEGO) toy, color . (&lt;__main__.ConstructionToy at 0x253feb611c8&gt;, &lt;__main__.Blue at 0x253feb61548&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(GREEN_ACTION_FIGURE) toy, color . (&lt;__main__.ActionFigure at 0x253ff09f208&gt;, &lt;__main__.Green at 0x253ff09f3c8&gt;) . # Separate the construction of an object from representation # allow same construction process for many representations # parse a complex representation, create different objects # Consider a SQL query builder class # allows step-by-step creation of a SQL query # Query is a complex entity with many different parts # Applications might build once, run multiple times # Separates object construction from its representation # parse a complex construction process into simple constituent operations . class Mobile: def __init__(self, name, weight, screen_size, ram, os, camera_mp, battery): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(name=&quot;Samsung S10&quot;, weight = &quot;157g&quot;, screen_size = &quot;6.1 inch&quot;, ram = &quot;8GB&quot;, os = &quot;android 9.0&quot;, camera_mp = &quot;12 megapixel&quot;, battery = &quot;3400 mAh&quot;) . samsung_s10.show() . name: Samsung S10 weight: 157g screen_size: 6.1 inch ram: 8GB os: android 9.0 camera_mp: 12 megapixel battery: 3400 mAh . to get rid of the long list of parameters we can have the features in the main program but directly setting attributes in the client program is wrong, it goes against encapsulate what varies principle . this is prone to errors and maintenance unfriendly . class Mobile(): def __init__(self): self.name = None self.weight = None self.screen_size = None self.ram = None self.os = None self.camera_mp = None self.battery = None def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . s10 = Mobile() . s10.name = &quot;Samsung S10&quot; s10.screen_size = &quot;6.1 inch&quot;, s10.os = &quot;android 9.0&quot;, s10.camera_mp = &quot;12 megapixel&quot;, s10.battery = &quot;3400 mAh&quot; . s10.show() . name: Samsung S10 weight: None screen_size: (&#39;6.1 inch&#39;,) ram: None os: (&#39;android 9.0&#39;,) camera_mp: (&#39;12 megapixel&#39;,) battery: 3400 mAh . now the features have been encapsulated in a seperate class called MyMobile the build method instantiates a new mobile object and encapsulates setting of sttributes | . class MyMobileBuilder(): def __init__(self): self.__mobile = Mobile() def get_mobile(self): return self.__mobile def build_name(self, name): self.__mobile.name = name def build_memory(self, ram): self.__mobile.ram = ram def build_camera(self, camera_mp): self.__mobile.camera_mp = camera_mp def build_otherfeatures(self, weight, screen_size, os, battery): self.__mobile.weight = weight self.__mobile.screen_size = screen_size self.__mobile.os = os self.__mobile.battery = battery . build the mobile, get the finished product and show the features . we solved - . long parameter list problem | encapsulating attributes | . builder = MyMobileBuilder() . builder.build_name(&#39;Samsung S10&#39;) builder.build_memory(&#39;8GB&#39;) builder.build_camera(&#39;16 megapixels&#39;) . mobile = builder.get_mobile() . mobile.show() . name: Samsung S10 weight: None screen_size: None ram: 8GB os: None camera_mp: 16 megapixels battery: None . class Mobile: def __init__(self, name, weight=&#39;157gm&#39;, screen_size=&#39;5inches&#39;, ram=&#39;8GB&#39;, os=&#39;Android&#39;, camera_mp=&#39;16 megapixels&#39;, battery=&#39;3400 mAh&#39;): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(&#39;Samsung S10&#39;) samsung_s10.show() . name: Samsung S10 weight: 157gm screen_size: 5inches ram: 8GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . samsung_s8 = Mobile(&#39;Samsung S8&#39;, screen_size=&#39;4.4inches&#39;, ram=&#39;4GB&#39;) samsung_s8.show() . name: Samsung S8 weight: 157gm screen_size: 4.4inches ram: 4GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . # Used when the cost of initializing objects is high # Number of objects in use at a time is low # Rate of object instantiation is high # Pools used to cache and manage objects # Avoid creating new objects, when an existing one is available # Reuse objects rather than incur the cost of creating one # common example: thread pools # some processes are embarrassingly parallel # threads are expensive to create and free up # use a thread pool -&gt; mitigates the overhead of pool creation # avoids needless re-instantiation and expensive acquisition of resources . class Connection: def __init__(self): self.__is_used = False # Imagine a very heavy-duty initialization process here # to set up the database connections and connect self.connect_to_database() def acquire(self): self.__is_used = True def release(self): self.__is_used = False def is_used(self): return self.__is_used def connect_to_database(self): pass . class ConnectionPool: def __init__(self, num_connections): self.__num_connections = num_connections self.__connections = [] for i in range(num_connections): self.__connections.append(Connection()) def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(3) . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253ff03aac8&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . conn_4 = pool.acquire() conn_4 is None . True . pool.release(conn_3) . conn_4 = pool.acquire() conn_4 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . pool.release(conn_2) . conn_5 = pool.acquire() conn_5 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . class ConnectionPool: __instance = None def __new__(cls, num_connections): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(ConnectionPool, cls).__new__(cls) cls.__instance.__num_connections = num_connections cls.__instance.__connections = [] for i in range(num_connections): cls.__instance.__connections.append(Connection()) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(2) . No instance exists, creating a new one . pool = ConnectionPool(2) . A previously created instance exists, returning that same one . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253feeed048&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253feeed308&gt; . conn_3 = pool.acquire() conn_3 is None . True . pool.release(conn_2) . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253feeed308&gt; . .",
            "url": "https://elydora.github.io/DataScienceBlog/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "relUrl": "/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "date": " • Jun 28, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Classes - Introduction",
            "content": "# Classes -&gt; have State (Attributes) and Behavior (Perform Actions) . # each entity is known as an instance or object # each objects has its own independent existence . # attributes are called member variables # functions perform actions on the member variables -&gt; called member functions # no limit for vars/functions . # Class variables -&gt; associated with the class itself; shared by all objects of the class # - declared outside of any method # - referred to by class name # Instance variables -&gt; associated with objects of a class; exclusive property # - declared inside any method # - referred using the self keyword . . # tries to capture the similarities and differences in real-world entities # Portray relationships # base, parent, super class | derived, child class, subclass . # Polymorphism - the ability of an object to behave in multiple ways # Encapsulation of data # Clear modular structure for code # Provides abstractions and data encapsulation # Easy to maintain and reuse code # Model real-world entities .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Classes - Inheritance",
            "content": "class Shape: pass class Shape(): pass class Shape(object): pass . class Shape: def __init__(self, shape_type): self.__type = shape_type def get_type(self): return self.__type . circle = Shape(&quot;circle&quot;) type(circle) . __main__.Shape . circle.get_type() . &#39;circle&#39; . square = Shape(&quot;square&quot;) type(square) . __main__.Shape . class Shape: def __init__(self, shape_type, color=&quot;Red&quot;): # optional self.__type = shape_type self.__color = color def get_type(self): return self.__type def get_color(self): return self.__color def get_area(self): pass def get_perimeter(self): pass . circle = Shape(&quot;circle&quot;) circle.get_color() . &#39;Red&#39; . class Circle(Shape): pass . circle = Circle(&quot;circle&quot;) . type(circle) . __main__.Circle . class Circle(Shape): def __init__(self): Shape.__init__(self, &quot;circle&quot;) . class Square(Shape): def __init__(self): Shape.__init__(self, &quot;square&quot;) . circle = Circle() square = Square() circle.get_type(), square.get_type() . (&#39;circle&#39;, &#39;square&#39;) . class Circle(Shape): def __init__(self, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) . circle = Circle() circle.get_color() . &#39;green&#39; . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . circle = Circle(5, color=&quot;orange&quot;) circle.get_area() . 78.53981633974483 . help(Circle) . Help on class Circle in module __main__: class Circle(Shape) | Circle(radius, color=&#39;green&#39;) | | Method resolution order: | Circle | Shape | builtins.object | | Methods defined here: | | __init__(self, radius, color=&#39;green&#39;) | Initialize self. See help(type(self)) for accurate signature. | | get_area(self) | | get_perimeter(self) | | - | Methods inherited from Shape: | | get_color(self) | | get_type(self) | | - | Data descriptors inherited from Shape: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): super().__init__(self, &quot;circle&quot;, color) # super is also possible self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . issubclass(Circle, Shape) . True . class Father: pass class Mother: pass . class Child1(Father, Mother): pass . help(Child1) . Help on class Child1 in module __main__: class Child1(Father, Mother) | Method resolution order: | Child1 | Father | Mother | builtins.object | | Data descriptors inherited from Father: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . class Father: def height(self): print(&quot;I have inherited my height from my father&quot;) class Mother: def intelligence(self): print(&quot;I have inherited my intelligence from my mother&quot;) class Child(Father, Mother): def experience(self): print(&quot;My experience are all my own&quot;) . c = Child() c.height() . I have inherited my height from my father . c.intelligence() . I have inherited my intelligence from my mother . class Hominidae(): def communication(self): print(&quot;They use auditory calls and visual cues.&quot;) def walk(self): print(&quot;They are knuckle-walkers, used to hang and swing from one tree to another.&quot;) class Human(Hominidae): def communication(self): print(&quot;They use language to communicate.&quot;) def walk(self): print(&quot;They are bipeds.&quot;) class Gorilla(Hominidae): def communication(self): print(&quot;They use twenty-five distinct vocalizations to communicate.&quot;) def walk(self): print(&quot;They are knuckle-walkers.&quot;) hominidae_1 = Hominidae() human_1 = Human() gorilla_1 = Gorilla() . hominidae_1.communication() human_1.communication() gorilla_1.communication() . They use auditory calls and visual cues. They use language to communicate. They use twenty-five distinct vocalizations to communicate. . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Classes - Getting Started",
            "content": "class Student: pass . object_1 = Student() . type(object_1) . __main__.Student . object_2 = Student() . object_1 . &lt;__main__.Student at 0x288a7e26148&gt; . object_2 . &lt;__main__.Student at 0x288a88928c8&gt; . isinstance(object_1, Student) . True . object_1.name = &#39;Michel&#39; object_1.email = &#39;Michel@xyz.com&#39; . object_1.name . &#39;Michel&#39; . object_1.school . AttributeError Traceback (most recent call last) &lt;ipython-input-12-68b03d9bbaba&gt; in &lt;module&gt; -&gt; 1 object_1.school AttributeError: &#39;Student&#39; object has no attribute &#39;school&#39; . object_3 = Student() object_3.name . AttributeError Traceback (most recent call last) &lt;ipython-input-13-b5626ff88877&gt; in &lt;module&gt; 1 object_3 = Student() -&gt; 2 object_3.name AttributeError: &#39;Student&#39; object has no attribute &#39;name&#39; . class Student: name = &quot;&quot; score = 0 active = True . s1 = Student() . s1.name = &quot;John&quot; s1.score = 50 s1.name, s1.score, s1.active . (&#39;John&#39;, 50, True) . # special methods are marked with __methodname__ class Student: def __init__(self): # can be anything, but self is standard print(&#39;Initialize called!&#39;) . s1 = Student() . Initialize called! . s2 = Student() s3 = Student() . Initialize called! Initialize called! . class Student: def __init__(self, name): # can be anything, but self is standard self.name = name # self refers to the current instance self.mail = name + &quot;.&quot; + &quot;@xyz.com&quot; . s1 = Student(&quot;Felix&quot;) s1.mail . &#39;Felix.@xyz.com&#39; . del s1.mail s1.mail . AttributeError Traceback (most recent call last) &lt;ipython-input-8-0ed8e4b3810a&gt; in &lt;module&gt; 1 del s1.mail -&gt; 2 s1.mail AttributeError: &#39;Student&#39; object has no attribute &#39;mail&#39; . class Competition: # class variable raise_amount = 1.04 def __init__(self, name, prize): self.name = name self.prize = prize def raise_prize(self): self.prize = self.prize * raise_amount . debate = Competition(&#39;Debate&#39;, 500) print(debate.raise_amount) . 1.04 . Competition.raise_amount . 1.04 . debate.__dict__ . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500} . Competition.__dict__ . mappingproxy({&#39;__module__&#39;: &#39;__main__&#39;, &#39;raise_amount&#39;: 1.04, &#39;__init__&#39;: &lt;function __main__.Competition.__init__(self, name, prize)&gt;, &#39;raise_prize&#39;: &lt;function __main__.Competition.raise_prize(self)&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Competition&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Competition&#39; objects&gt;, &#39;__doc__&#39;: None}) . debate.raise_amount = 10 debate.__dict__ # new instance attribute is added . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500, &#39;raise_amount&#39;: 10} . class Competition: def __init__(self, name, prize): self.name = name self.prize = prize self.participants = [] . debate = Competition(&#39;Debate&#39;, 500) debate.participants . [] . Competition.participants . AttributeError Traceback (most recent call last) &lt;ipython-input-5-ea531b615844&gt; in &lt;module&gt; -&gt; 1 Competition.participants AttributeError: type object &#39;Competition&#39; has no attribute &#39;participants&#39; . debate.participants.append(&#39;Alice&#39;) . debate.participants . [&#39;Alice&#39;] . # hack for private attributes: class Dog: def __init__(self, name, breed): self.__name = name self.__breed = breed def print_details(self): print(&#39;My name is %s and I am a %s&#39; % (self.__name, self.__breed)) . d1 = Dog(&quot;Moje&quot;, &quot;Golden Retriever&quot;) d1.print_details() . My name is Moje and I am a Golden Retriever . d1.__dict__ . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;} . d1.__name = &quot;Oba&quot; d1.print_details() # doesn&#39;t update . My name is Moje and I am a Golden Retriever . d1.__dict__ # new attribute created . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;, &#39;__name&#39;: &#39;Oba&#39;} . d1._Dog__breed = &quot;Husky&quot; # makes it harder to change, but can be changed d1.print_details() . My name is Moje and I am a Husky . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Classes - Advanced Functionality",
            "content": "class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes rowing = Competition(&quot;Rowing&quot;, 10000) . print(rowing) . &lt;__main__.Competition object at 0x000001D68AE718C8&gt; . rowing . &lt;__main__.Competition at 0x1d68ae718c8&gt; . class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes def __repr__(self): # representation for print function, if __str__ is not defined return &quot;(&#39;{}&#39;, {})&quot;.format(self.__name, self.__prize) . archery = Competition(&quot;Archery&quot;, 8000) . print(archery) . (&#39;Archery&#39;, 8000) . str(archery) # looks for special method __str__() . &#34;(&#39;Archery&#39;, 8000)&#34; . repr(archery) . &#34;(&#39;Archery&#39;, 8000)&#34; . class Competition: def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) . archery = Competition(&quot;Archery&quot;, &quot;United Kingdom&quot;, 7500) archery . Competition: Archery held in United Kingdom, prize: 7500 . print(archery) . &#39;Archery United Kingdom - 7500&#39; . 1 + 2 . 3 . int.__add__(1, 2) . 3 . str.__add__(&quot;a&quot;, &quot;b&quot;) . &#39;ab&#39; . class Savings: def __init__(self, amount): self.__amount = amount . s1 = Savings(1000) s2 = Savings(22000) . s1 + s2 . TypeError Traceback (most recent call last) &lt;ipython-input-27-07ecabcb1b41&gt; in &lt;module&gt; -&gt; 1 s1 + s2 TypeError: unsupported operand type(s) for +: &#39;Savings&#39; and &#39;Savings&#39; . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount . s1 = Savings(1000) s2 = Savings(22000) s1 + s2 . 23000 . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount def __sub__(self, other): return self.__amount - other.__amount . s1 = Savings(5000) s2 = Savings(457) s1 - s2 . 4543 . 1.0 * 2.1 . 2.1 . float.__mul__(1.0, 2.1) . 2.1 . float.__mul__(1, 2.1) . TypeError Traceback (most recent call last) &lt;ipython-input-37-ee0b82aa5938&gt; in &lt;module&gt; -&gt; 1 float.__mul__(1, 2.1) TypeError: descriptor &#39;__mul__&#39; requires a &#39;float&#39; object but received a &#39;int&#39; . 10 // 3 . 3 . int.__floordiv__(10, 3) . 3 . int.__mod__(4, 2) . 0 . int.__mod__(10, 3) . 1 . int.__pow__(6, 2) . 36 . len(&quot;test&quot;) . 4 . str.__len__(&quot;test&quot;) . 4 . some_list = [1, 4, 5, 7, 2] len(some_list) . 5 . class Participants: def __init__(self): self.__participants = [] def add_participants(self, name): self.__participants.append(name) def __len__(self): return len(self.__participants) . participants = Participants() participants.add_participants(&quot;Felix&quot;) participants.add_participants(&quot;Johan&quot;) participants.add_participants(&quot;Max&quot;) . len(participants) . 3 . class Wrestler: def __init__(self): self.__name = &quot;&quot; def set_name(self, name): print(&quot;setter method called&quot;) self.__name = name def get_name(self): print(&quot;getter method called&quot;) return self.__name def del_name(self): del self.__name name = property(get_name, set_name, del_name) . w = Wrestler() . w.name = &quot;Kart&quot; . setter method called . w.name . getter method called . &#39;Kart&#39; . class WrestlerNew: def __init__(self, name): self.__name = name @property # this is the method for accessing def name(self): print(&quot;getter method called&quot;) return self.__name @name.setter # this is the method for setting new vals def name(self, value): print(&quot;setter method called&quot;) self.__name = value @name.deleter def name(self): del self.__name . w1 = WrestlerNew(&quot;Rey&quot;) . w1.name . getter method called . &#39;Rey&#39; . class Competition: __raise_amount = 1.04 # class variable def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def raise_prize(self): self.__prize = self.__prize * self.__raise_amount def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) @classmethod def get_raise_amount(cls): return cls.__raise_amount @classmethod def set_raise_amount(cls, amount): cls.__raise_amount = amount . c1 = Competition(&quot;Running&quot;, &quot;Germany&quot;, 50000) . c1.set_raise_amount(2) . c1.get_raise_amount() . 2 . Competition.get_raise_amount() . 2 . class Rectangle: @staticmethod # cannot access class variables def area(x,y): return x * y . Rectangle.area(5,5) . 25 . from abc import ABC, abstractmethod class Hominidae(): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . chimpanzee = Hominidae() chimpanzee.behavior() . Blabla . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . paul = Human() paul.diet() . Omnivorous . class Hominidae(ABC): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h = Hominidae() . h.behavior() . Blabla . h.diet() . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . myra = Human() myra.diet() myra.walk() . Omnivorous Bipeds . class Hominidae(ABC): @abstractmethod # how to do it def diet(self): pass @abstractmethod def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h1 = Hominidae() . TypeError Traceback (most recent call last) &lt;ipython-input-131-df612faa022d&gt; in &lt;module&gt; -&gt; 1 h1 = Hominidae() TypeError: Can&#39;t instantiate abstract class Hominidae with abstract methods diet, walk . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Implementing Data Structures",
            "content": "def addition(num1, num2): total = num1 + num2 print(&quot;The sum of %d and %d is %d&quot; %(num1, num2, total)) . addition(10, 4) . The sum of 10 and 4 is 14 . def addition(num1, num2): num_iterations = 0 total = num1 + num2 num_iterations += 1 print(&quot;The sum of %d and %d is %d n total number: %d&quot; %(num1, num2, total, num_iterations)) . addition(50,10) # O(1) operation, number of operations is constant, no matter the input . The sum of 50 and 10 is 60 total number: 1 . def check_prime1(number): num_iterations = 0 for i in range(2, number): num_iterations += 1 if number%i == 0: print(&quot;%d is not a prime number n Total number of iterations = %d&quot; %(number, num_iterations)) return print(&quot;%d is a prime number nTotal number of iterations = %d&quot; %(number, num_iterations)) . check_prime1(10) . 10 is not a prime number Total number of iterations = 1 . check_prime1(50) . 50 is not a prime number Total number of iterations = 1 . check_prime1(1) . 1 is a prime number Total number of iterations = 0 . check_prime1(49) . 49 is not a prime number Total number of iterations = 6 . check_prime1(191) . 191 is a prime number Total number of iterations = 189 . # that takes longer, if the input list gets longer . def print_pairs(number_list): num_iterations = 0 n = len(number_list) for i in range(n): for j in range(n): print(number_list[i], number_list[j]) num_iterations += 1 print(&quot;Total iterations are %d&quot; % num_iterations) . print_pairs([123,67]) . 123 123 123 67 67 123 67 67 Total iterations are 4 . print_pairs([123,67, 25, 79]) . 123 123 123 67 123 25 123 79 67 123 67 67 67 25 67 79 25 123 25 67 25 25 25 79 79 123 79 67 79 25 79 79 Total iterations are 16 . . from queue import Queue olympics = Queue(5) olympics . &lt;queue.Queue at 0x2e919de0708&gt; . olympics.put(&quot;United Statues(USA)&quot;) olympics.put(&quot;Great Britain(GBR)&quot;) . olympics.empty() # O(1) . False . olympics.full() # O(1) . False . olympics.qsize() # O(1) . 2 . olympics.put(&quot;China(CHN)&quot;) olympics.put(&quot;Russia(RUS)&quot;) olympics.put(&quot;Germany(GER)&quot;) . olympics.full() . True . olympics.qsize() . 5 . olympics.get() . &#39;United Statues(USA)&#39; . olympics.qsize() . 4 . olympics.full() . False . stack = [] stack.append(&quot;United States&quot;) stack.append(&quot;Great Britain&quot;) stack.append(&quot;China&quot;) . stack . [&#39;United States&#39;, &#39;Great Britain&#39;, &#39;China&#39;] . stack.pop() . &#39;China&#39; . class Node: def __init__(self, dataval=None, nextval=None): self.dataval = dataval self.nextval = nextval def __repr__(self): return repr(self.dataval) class LinkedList: def __init__(self): self.head = None def __repr__(self): # O(N) nodes = [] curr = self.head while curr: nodes.append(repr(curr)) curr = curr.nextval return &quot;[&quot; + &quot;-&gt;&quot;.join(nodes) + &quot;]&quot; def prepend(self, dataval): # O(1) self.head = Node(dataval=dataval, nextval = self.head) def append(self, dataval): if not self.head: self.head = Node(dataval=dataval) return curr = self.head while curr.nextval: curr = curr.nextval curr.nextval = Node(dataval=dataval) def add_after(self, middle_dataval, dataval): if middle_dataval is None: print(&quot;Data to insert after not specified&quot;) return curr = self.head while curr and curr.dataval != middle_dataval: curr = curr.nextval new_node = Node(dataval = dataval) new_node.nextval = curr.nextval curr.nextval = new_node def find(self, data): curr = self.head while curr and curr.dataval != data: curr = curr.nextval return curr def remove(self, data): curr = self.head prev = None while curr and curr.dataval != data: prev = curr curr = curr.nextval if prev is None: self.head = curr.nextval elif curr: prev.nextval = curr.nextval curr.nextval = None def reverse(self): curr = self.head prev_node = None next_node = None while curr: nextval = curr.nextval curr.nextval = prev_node prev_node = curr curr = nextval self.head = prev_node . numbers = LinkedList() . numbers . [] . numbers.append(&quot;two&quot;) numbers.append(&quot;three&quot;) numbers . [&#39;two&#39;-&gt;&#39;three&#39;] . numbers.prepend(&quot;one&quot;) numbers . [&#39;one&#39;-&gt;&#39;two&#39;-&gt;&#39;three&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Fundamental Data Structures",
            "content": "# make difficult operations possible # occupy less space and still represent the complexity of information and # its interrelationships in an intuitive way # data structures and algorithms go hand-in-hand # A set is extremely fast for membership and containment queries # stacks can be used for undo functionality in applications as well as back functionality # index data structures # hash tables # graphs for relationships # data structures are concrete representations of data from the point of view of an implementor # they specify the actual implementation of the structure in code to meet the expected behavior . Hallo . # Time (# of operations / amount of processing) # Space (make best use of available space, memory and disk space needed) # Network (overall network bandwidth, network speed) # efficient = uses fewer resources along all these axes # using more of the resources that are plenty, and less of those who lack # performance indicates how much of these resources are used by the code # == Performance can be measured in terms of complexity # Complexity is a measure of how resource requirements change as the size of the problem gets larger # The higher the complexity of a overall problem, the lower the performance . 2 . # Read - Write - Assignment - Test # do not worry about the number of operations # be worried how that number changes is based on the input size # that is how performance changes based on input size # focus on the worst case performance # what is the maximum number of basic operations that might have to be performed based on the input # Complexity varies with the algorithm . # Represents the complexity of an algorithm # An algorithm whose complexity does not change with the input size is O(1) # -&gt; the algorithm is said to have constant time complexity # The algorithm is said to have constant time complexity # It takes the same amount of time, even if the input size is doubled, tripled, or increased to any level . # The complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases # Lower order terms and constants do not matter while expressing complexity # O(N^2 + 1000) is equivalent to O(N^2) -&gt; N is assumed very large # O(N^2+N) is equivalent to O(N^2) . . # Header points to the first element # Best way to count is to increment/decrement a counter at every list operation # Adding: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Deleting: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Counting: Iterating -&gt; O(1), Increment/Decrement a permanent Counter -&gt; O(1) # Reversing: O(N) . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # LIFO principle # Insertion and deletion at the same end . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # FIFO principle # Insertion and deletion at opposite ends . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Complex Data Types - Lists and Tuples",
            "content": "empty_list = [] empty_list . list_str=[&quot;Toyota&quot;,&quot;VW&quot;,&quot;BMW&quot;,&quot;Mercedes&quot;] list_str . list_bool=[True, False, False, True] list_bool . list_str[1] . list_str[len(list_str)-1] . list_str[-1] . list_str[0] = &quot;Hyundai&quot; list_str . list_str.append(&quot;Opel&quot;) list_str . list_str += [&#39;Dacia&#39;, &#39;Ford&#39;] list_str . list_str.sort() list_str . list_str.reverse() list_str . list_str.pop() list_str . list_str.count(&quot;Dacia&quot;) . print(list_str) . new_list = list_str.copy() list_str.clear() list_str . del list_str . list_2 = sorted(new_list) # whole new list . any([0]) # greater 0 . any([0, 1]) . all([0,1]) . new_list[0:2] # creates a deep copy . new_list[0:100] . new_list[1:] . new_list[:3] . new_list[:-1] . new_list[-4:-1] . new_list[0:5:2] . &quot;Dacia&quot; in new_list . new_list[::-3] . new_list[100] . new_list.count() .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Complex Data Types - Dictionaries and Sets",
            "content": "empty_dict = {} empty_dict . {} . bike_owners = {&quot;James&quot;:&quot;Ducati Monster 1200&quot;, &quot;Jacob&quot;:&quot;Ducati Scrambler 1100&quot;} bike_owners . {&#39;James&#39;: &#39;Ducati Monster 1200&#39;, &#39;Jacob&#39;: &#39;Ducati Scrambler 1100&#39;} . bike_owners[&quot;Jacob&quot;] . &#39;Ducati Scrambler 1100&#39; . int_dict = {1:45, 2:55, 3:65} int_dict[1] . 45 . int_dict.keys() . dict_keys([1, 2, 3]) . 1 in int_dict.keys() . True . mixed_dict = {False: &quot;Daniel&quot;, &quot;Aria&quot;:[1,2,3], &quot;Jacob&quot;:True} mixed_dict . {False: &#39;Daniel&#39;, &#39;Aria&#39;: [1, 2, 3], &#39;Jacob&#39;: True} . mixed_dict[False] . &#39;Daniel&#39; . int_dict[1] = 78 int_dict . {1: 78, 2: 55, 3: 65} . del int_dict[3] int_dict . {1: 78, 2: 55} . fruits = { &quot;Banana&quot;:[50,60,75,99], &quot;Apple&quot;:[48,86,47,25], &quot;Strawberries&quot;:[70,80,60,65] } print(fruits[&quot;Banana&quot;]) print(fruits[&quot;Banana&quot;][3]) fruits[&quot;Banana&quot;][3]=50 print(fruits[&quot;Banana&quot;][3]) . [50, 60, 75, 99] 99 50 . fruit_qtc_consumed = { &quot;Banana&quot;: {&quot;Fri&quot;:90, &quot;Mo&quot;:80, &quot;Di&quot;:90}, &quot;Apple&quot;:{&quot;Fri&quot;:10, &quot;Mo&quot;:12, &quot;Di&quot;:13}, &quot;Strawberry&quot;:{&quot;Fri&quot;:47, &quot;Mo&quot;:48, &quot;Di&quot;:20}, } print(fruit_qtc_consumed[&quot;Strawberry&quot;]) print(fruit_qtc_consumed[&quot;Strawberry&quot;][&quot;Fri&quot;]) . {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20} 47 . len(fruit_qtc_consumed) . 3 . len(fruit_qtc_consumed.keys()) . 3 . sorted(fruit_qtc_consumed) . [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Strawberry&#39;] . sorted(fruit_qtc_consumed, reverse=True) . [&#39;Strawberry&#39;, &#39;Banana&#39;, &#39;Apple&#39;] . fruit_qtc_consumed.items() . dict_items([(&#39;Banana&#39;, {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}), (&#39;Apple&#39;, {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}), (&#39;Strawberry&#39;, {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20})]) . copy = fruit_qtc_consumed.copy() copy . {&#39;Banana&#39;: {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}, &#39;Apple&#39;: {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}, &#39;Strawberry&#39;: {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20}} . copy.pop(&quot;Banana&quot;) . {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90} . persons1 = {&quot;Ethan&quot;:45,&quot;Monica&quot;:88,&quot;Max&quot;:10} persons2 = {&quot;Ethan&quot;:46,&quot;Claus&quot;:47,&quot;Rainer&quot;:44} print(persons1) persons1.update(persons2) print(persons1) . {&#39;Ethan&#39;: 45, &#39;Monica&#39;: 88, &#39;Max&#39;: 10} {&#39;Ethan&#39;: 46, &#39;Monica&#39;: 88, &#39;Max&#39;: 10, &#39;Claus&#39;: 47, &#39;Rainer&#39;: 44} . persons2.clear() persons2 . {} . del persons2 . set_string = {&quot;Emma&quot;, &quot;Olivia&quot;, &quot;Ava&quot;, &quot;Mia&quot;} set_string . {&#39;Ava&#39;, &#39;Emma&#39;, &#39;Mia&#39;, &#39;Olivia&#39;} . print(set_string) # no intrinsic ordering . {&#39;Ava&#39;, &#39;Mia&#39;, &#39;Emma&#39;, &#39;Olivia&#39;} . empty_set = set() . mixed_set = {&quot;Emmma&quot;, 5, 1.5, True,(1,2,3,4)} #Lists are not allowed . student_set = {&quot;Emma&quot;, &quot;Marc&quot;, &quot;Janine&quot;, &quot;Emma&quot;} student_set # duplicates are eliminated . {&#39;Emma&#39;, &#39;Janine&#39;, &#39;Marc&#39;} . student_set[1] . TypeError Traceback (most recent call last) &lt;ipython-input-35-a8e02497ae7e&gt; in &lt;module&gt; -&gt; 1 student_set[1] 2 3 TypeError: &#39;set&#39; object is not subscriptable . student_set.add(&quot;Felix&quot;) . len(student_set) . 4 . max(student_set) . &#39;Marc&#39; . student_set.remove(&quot;Felix&quot;) student_set.discard(&quot;Felix&quot;) . number1={1,2,3,4,5} number2={4,5,6,7,8} number3={7,8,9,10,11} . number1.union(number2) . {1, 2, 3, 4, 5, 6, 7, 8} . number1.difference(number2) . {1, 2, 3} . number1.isdisjoint(number2) . False . number1.isdisjoint(number3) . True . car_matrix = [[&quot;Hennessey Venom GT&quot;, 1244], [&quot;SSC Ultimate Aero&quot;, 1287], [&quot;Zenvo ST1&quot;, 1100]] car_matrix . [[&#39;Hennessey Venom GT&#39;, 1244], [&#39;SSC Ultimate Aero&#39;, 1287], [&#39;Zenvo ST1&#39;, 1100]] . len(car_matrix) . 3 . len(car_matrix[1]) . 2 . car_matrix[1][0] . &#39;SSC Ultimate Aero&#39; . car_matrix[1] . [&#39;SSC Ultimate Aero&#39;, 1287] . car_matrix[1][0:2] . [&#39;SSC Ultimate Aero&#39;, 1287] . my_list = [&quot;Leo&quot;,18,&quot;Aaron&quot;,15,&quot;Max&quot;,25,&quot;Sofi&quot;,22,&quot;Marques&quot;,2,&quot;Julia&quot;,91,] print(my_list) print(tuple(my_list)) # tuple is immutable . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] (&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91) . my_list1 = [[&quot;Leo&quot;,18],[&quot;Aaron&quot;,48],[&quot;Max&quot;,25],[&quot;Sofi&quot;,22],[&quot;Marques&quot;,2],[&quot;Julia&quot;,91]] tuple(my_list1) . ([&#39;Leo&#39;, 18], [&#39;Aaron&#39;, 48], [&#39;Max&#39;, 25], [&#39;Sofi&#39;, 22], [&#39;Marques&#39;, 2], [&#39;Julia&#39;, 91]) . d_list = dict(my_list1) names = list(d_list) names . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] . d_list2 = dict(my_list1) names2 = list(d_list2.values()) names2 . [18, 48, 25, 22, 2, 91] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Complex Data Types - Deep and Shallow Copies",
            "content": "old_str = &quot;Python&quot; old_str . &#39;Python&#39; . new_str = old_str print(old_str) print(new_str) . Python Python . new_str[2] = &quot;T&quot; . TypeError Traceback (most recent call last) &lt;ipython-input-3-b6e8ff6bdf2e&gt; in &lt;module&gt; -&gt; 1 new_str[2] = &#34;T&#34; TypeError: &#39;str&#39; object does not support item assignment . import copy . first_str = &quot;Will&quot; second_str = copy.copy(first_str) print(first_str) print(second_str) . Will Will . second_str = &quot;Smith&quot; print(first_str) print(second_str) . Will Smith . first_str = &quot;Johnny&quot; second_str = copy.deepcopy(first_str) # the same print(first_str) print(second_str) . Johnny Johnny . second_str = &quot;Depp&quot; print(first_str) print(second_str) . Johnny Depp . names = [&quot;Jan&quot;, &quot;Felix&quot;, &quot;Ralph&quot;] second_names = names . second_names[1] = &quot;Maria&quot; print(names) print(second_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . third_names = copy.copy(names) third_names[0] = &quot;Julia&quot; print(names) print(third_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Julia&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Functions - General",
            "content": "country = &quot;USA&quot; def some_fn(): print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): country = &quot;India&quot; print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): global country country = &quot;Bangladesh&quot; print(country) some_fn() . country . fruits_list = [&quot;Apple&quot;, &quot;Grapes&quot;, &quot;Mango&quot;, &quot;Bananas&quot;] def change_list(fruits_list): fruits_list[0] = &quot;Kiwi&quot; fruits_list = [&quot;Kiwi&quot;] # does nothing on the outside print(&quot;Inside the function: &quot;, fruits_list) change_list(fruits_list) print() print(&quot;Outside the function: &quot;, fruits_list) . help(&quot;modules&quot;) . import math . print(math.pi) . math.e . math.ceil(8.1) . math.floor(8.1) . math.pow(2,4) . math.sqrt(24) . import os . os.getcwd() . os.environ . user = os.environ[&quot;USERNAME&quot;] user . os.environ[&quot;PATH&quot;] . os.listdir() . os.listdir(&quot;.&quot;) . os.path.isdir(os.environ[&quot;PATH&quot;]) . os.path.isfile(os.environ[&quot;PATH&quot;]) . import random . random.random() . random.random() . random.randint(0, 10) . listA = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] random.choice(listA) . import datetime datetime.date.today() . datetime.datetime.now() . def hello(name): print(&quot;Hello!&quot;, name) hello(&quot;Bruce&quot;) . hello . greet = hello . greet(&quot;Max&quot;) . calculate_length = len calculate_length(&quot;SomeString&quot;) . calculate_length == len . import math def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) def diameter_circle_fn(r): pass calculate(10, fn=diameter_circle_fn) . def area_rectangle_fn(length, breadth): return length * breadth def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) calculate(20, 40, fn=area_rectangle_fn) . def square(x): return x * x . result = square(5) result . square . sq = square . result = sq(12) result . cube_of = lambda x: x * x * x result = cube_of(3) result . cube_of . add = lambda x, y: x + y . result = add(5, 10) result . (lambda x: x + 2)(10) . (lambda x:x * 10)(22) . def check_if_even(x): assert x % 2 == 0 . check_if_even(2) . check_if_even(3) . even_check_lambda = lambda x : assert x % 2 == 0 . total_score = lambda math, physics, chemistry, biology=50: math+physics+chemistry+biology . total_score(math=50, physics=10, chemistry=23) . (lambda **num_dictionary: sum(num_dictionary.values()))(a=23, b=34, c=45) . num_list = [1,5,6,7,11,78,99,34,105,214] . filter(lambda x: x &gt; 10, num_list) . greater_than_10_list = list(filter(lambda x: x &gt; 10, num_list)) greater_than_10_list . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Functions - Advanced",
            "content": "def hello(name): print(&quot;Hello&quot;, name) hello(name) #hello(&quot;Ron&quot;) . import sys sys.getrecursionlimit() . 3000 . def increment(num): print(num, end = &quot; &quot;) increment(num + 1) return #increment(1) . def decrement(num): while num &gt; 0: print(num) num = num - 1 decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def decrement(num): if num == 0: return print(num) decrement(num - 1) decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def generator(): print(&quot;One!&quot;) yield 1 # control execution flow print(&quot;Two!&quot;) yield 2 print(&quot;Three!&quot;) yield 3 g = generator() # no code execution g . &lt;generator object generator at 0x000001A6BE9FBCC8&gt; . next(g) # execute g until the first yield statement . One! . 1 . next(g) # second yield statement . Two! . 2 . next(g) # until third statement . Three! . 3 . next(g) . StopIteration Traceback (most recent call last) &lt;ipython-input-20-e734f8aca5ac&gt; in &lt;module&gt; -&gt; 1 next(g) StopIteration: . g2 = generator() g . next(g2) . def generator(): print(&quot;One!&quot;) n = 1 yield n # control execution flow print(&quot;Two!&quot;) n += 1 yield n print(&quot;Three!&quot;) n += 1 yield n g3 = generator() . next(g3) . next(g3) . def generate_even_numbers(limit): for i in range(0, limit, 2): yield i . g = generate_even_numbers(7) . next(g) . next(g) . next(g) . next(g) . next(g) . g2 = generate_even_numbers(20) g2_list = list(g2) . g2_list . def generate_powers_of_two(): num = 0 while True: num = num + 1 yield 2 ** num . g = generate_powers_of_two() . next(g) . next(g) . def nested_hello_fn(): def hello(): print(&quot;Hello Cathy!&quot;) hello() . nested_hello_fn() . hello() . def get_hello_fn(): # every closure has its own local state (do not share local variables) def hello(): print(&quot;Hello Cathy!&quot;) return hello . hello_fn = get_hello_fn() . hello_fn() . def print_message(): print(&quot;Yohoo! Decorators are cool!&quot;) . print_message() . import random def highlight(): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) print_message() print(annotate * 50) highlight() . def make_highlighted(func): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) func() print(annotate * 50) make_highlighted(print_message) . @make_highlighted # that&#39;S how they are really used def print_a_message(): print(&quot;Now you&#39;ll see how decorators are used&quot;) print_a_message . def plus_highlight(func): def highlight(): print(&quot;+&quot;*50) func() print(&quot;+&quot;*50) return highlight def asterisk_highlight(func): def highlight(): print(&quot;*&quot;*50) func() print(&quot;*&quot;*50) return highlight @plus_highlight @asterisk_highlight def hello(): print(&quot;hello!&quot;) hello() . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://elydora.github.io/DataScienceBlog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "SAP developer by day, Python developer by night. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://elydora.github.io/DataScienceBlog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://elydora.github.io/DataScienceBlog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}