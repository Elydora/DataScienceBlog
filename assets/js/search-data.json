{
  
    
        "post0": {
            "title": "Creational Design Patterns",
            "content": "# Singleton # a class of which only a single instance can exist # Ensure a class is instantiated only once, and provide a global point of access to it # When: # - no clear owner of the object, i. e. a global object (e. g. logger) # - when you want to use lazy instantiation # - when you need a single global way to access the object # python offers a global object pattern . # Implementation class Logger: __instance = None def __init__(self): raise RuntimeError(&#39;Call get_instance() instead&#39;) @classmethod def get_instance(cls): if cls.__instance is None : print(&#39;No instance exists, creating a new one&#39;) cls.__instance = cls.__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger1 = Logger.get_instance() logger1 . logger2 = Logger.get_instance() . logger2 . # Pythonic implementation # new is always called first -&gt; it creates the instance, cls is reference to not yet existing instance # init is used to initialize the existing instance -&gt; self is a reference to the instance class PythonicLogger: __instance = None def __init__(self): print(&#39;Object initialized&#39;) # put your custom code here # is called every time - could be expensive def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(PythonicLogger, cls).__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger3 = PythonicLogger() logger3 . logger4 = PythonicLogger() logger4 . class SuperLogger: __instance = None def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(SuperLogger, cls).__new__(cls) # Place all initialization code here else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger5 = SuperLogger() logger5 . logger6 = SuperLogger() logger6 . logger5 == logger6 . # Global Object Pattern # Global Objects which expose methods import logger . logger.INFO . logger.WARNING . file_logger = logger.FILE_LOGGER file_logger.log(&quot;logging message&quot;) . # Factory &amp; Abstract Factory Design Patterns # Separate the creation of objects from their use # Class creation or Object creation # Class-creation patterns use inheritance # Object-creation patterns use delegation # Factory method is specified in base class, implemented in derived classes # Creates an instance of several derived classes # Define an interface for creating an object, but let subclasses decide which class to instantiate # Used to postpone instantiation - responsibility passes from base class to derived classes # Factory method -&gt; create an instance of any of many derived classes # Abstract F. pattern -&gt; create an instance of any one of many families of derived classes # Abstract Factory: create instances of several families of classes # encapsulate platform dependencies # Use case: Working with Oracle or MS-SQL databases -&gt; each represents a family of classes # Microsoft Factory | Oracle Factory . # Factory Method class Product: def __init__(self, name, price): self.__name = name self.__price = price def get_price(self): return self.__price . class MacBookAir(Product): def __init__(self, memory, os): Product.__init__(self, &#39;MacBookAir&#39;, 1031) self.__memory = memory self.__os = os class AppleIPad(Product): def __init__(self, generation): Product.__init__(self, &#39;AppleIPad&#39;, 529) self.__generation = generation class AppleIWatch(Product): def __init__(self): Product.__init__(self, &#39;AppleIWatch&#39;, 264) . class ProductFactory(): @staticmethod def create(item_name, *args): if item_name == &#39;MacBookAir&#39;: return MacBookAir(*args) elif item_name == &#39;AppleIPad&#39;: return AppleIPad(*args) elif item_name == &#39;AppleIWatch&#39;: return AppleIWatch(*args) . air = ProductFactory.create(&#39;MacBookAir&#39;, &#39;16GB&#39;, &#39;Sierra&#39;) air.__dict__ . ipad = ProductFactory.create(&#39;AppleIPad&#39;, &#39;2nd&#39;) ipad.__dict__ . iwatch = ProductFactory.create(&#39;AppleIWatch&#39;) iwatch.__dict__ . https://realpython.com/factory-method-python/ . import json import xml.etree.ElementTree as et class Movie: def __init__(self, movie_id, name, director): self.movie_id = movie_id self.name = name self.director = director . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) elif fmt == &#39;XML&#39;: movie_info = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_info, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_info, &#39;director&#39;) director.text = movie.director return et.tostring(movie_info, encoding=&#39;unicode&#39;) else: raise ValueError(fmt) . movie = Movie(&#39;578&#39;, &#39;Avengers:End Game&#39;, &#39;Russo brothers&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . serializer.serialize(movie, &#39;YAML&#39;) . Complex logical code uses if/elif/else structures to change the behavior of an application. Using if/elif/else conditional structures makes the code harder to read, harder to understand, and harder to maintain. . When a new format is introduced: The method will have to change to implement the serialization to that format. . | When the movie object changes: Adding or removing properties to the Song class will require the implementation to change in order to accommodate the new structure. . | When the string representation for a format changes (plain JSON vs JSON API): The .serialize() method will have to change if the desired string representation for a format changes because the representation is hard-coded in the .serialize() method implementation. . | . Refactoring Code Into the Desired Interface . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: return self._serialize_to_json(movie) elif fmt == &#39;XML&#39;: return self._serialize_to_xml(movie) else: raise ValueError(format) def _serialize_to_json(self, movie): movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) def _serialize_to_xml(self, movie): movie_element = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_element, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_element, &#39;director&#39;) director.text = movie.director return et.tostring(movie_element, encoding=&#39;unicode&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . # Abstract Factory . Provide an interface for creating families of related or dependent objects without specifying their concrete classes. . An abstract factory is a factory that returns factories.A normal factory can be used to create sets of related objects. An abstract factory returns factories. Thus, an abstract factory is used to return factories that can be used to create sets of related objects. . When the system needs to be independent of how its object are created, composed, and represented. | When the family of related objects has to be used together, then this constraint needs to be enforced. | When you want to provide a library of objects that does not show implementations and only reveals interfaces. | When the system needs to be configured with one of a multiple family of objects. | . import abc . create an interface for Toys and color . class Toy(metaclass=abc.ABCMeta): @abc.abstractmethod def show(self): pass class Color(metaclass=abc.ABCMeta): @abc.abstractmethod def show_color(self): pass . class Car(Toy): def show(self): print(&quot;Remote controlled car&quot;) class ActionFigure(Toy): def show(self): print(&quot;Captain America action figure&quot;) class ConstructionToy(Toy): def show(self): print(&quot;Lego&quot;) . class Red(Color): def show_color(self): print(&quot;red&quot;) class Green(Color): def show_color(self): print(&quot;green&quot;) class Blue(Color): def show_color(self): print(&quot;blue&quot;) . car = Car() red = Red() red.show_color(), car.show() . red Remote controlled car . (None, None) . lego = ConstructionToy() green = Green() green.show_color(), lego.show() . green Lego . (None, None) . class AbstractFactory(metaclass=abc.ABCMeta): @abc.abstractmethod def get_color(self): pass @abc.abstractmethod def get_toy(self): pass . Create concrete classes implementing the same interface. . create Factory classes extending AbstractFactory . class ColorfulToysFactory(AbstractFactory): def get_toy(self, toy_type): if toy_type == None: return None if toy_type == &quot;car&quot;: return Car() elif toy_type == &quot;action figure&quot;: return ActionFigure() elif toy_type == &quot;construction toy&quot;: return ConstructionToy() return None def get_color(self, color_type): if color_type == None: return None if color_type == &quot;red&quot;: return Red() elif color_type == &quot;green&quot;: return Green() elif color_type == &quot;blue&quot;: return Blue() return None . RED_CAR = &#39;red_car&#39; BLUE_LEGO = &#39;blue_lego&#39; GREEN_ACTION_FIGURE = &#39;green_action_figure&#39; . Use the FactoryProducer to get AbstractFactory in order to get factories of concrete classes by passing an information such as type . class ColorfulToysProducer: __colorful_toys_factory = ColorfulToysFactory() @classmethod def get_toy_and_color(cls, choice): toy = None color = None if choice == RED_CAR: toy = cls.__colorful_toys_factory.get_toy(&#39;car&#39;) color = cls.__colorful_toys_factory.get_color(&#39;red&#39;) elif choice == BLUE_LEGO: toy = cls.__colorful_toys_factory.get_toy(&#39;construction toy&#39;) color = cls.__colorful_toys_factory.get_color(&#39;blue&#39;) elif choice == GREEN_ACTION_FIGURE: toy = cls.__colorful_toys_factory.get_toy(&#39;action figure&#39;) color = cls.__colorful_toys_factory.get_color(&#39;green&#39;) return toy, color . toy, color = ColorfulToysProducer.get_toy_and_color(RED_CAR) toy, color . (&lt;__main__.Car at 0x253feb8a748&gt;, &lt;__main__.Red at 0x253ff224fc8&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(BLUE_LEGO) toy, color . (&lt;__main__.ConstructionToy at 0x253feb611c8&gt;, &lt;__main__.Blue at 0x253feb61548&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(GREEN_ACTION_FIGURE) toy, color . (&lt;__main__.ActionFigure at 0x253ff09f208&gt;, &lt;__main__.Green at 0x253ff09f3c8&gt;) . # Builder Pattern # Separate the construction of an object from representation # allow same construction process for many representations # parse a complex representation, create different objects # Consider a SQL query builder class # allows step-by-step creation of a SQL query # Query is a complex entity with many different parts # Applications might build once, run multiple times # Separates object construction from its representation # parse a complex construction process into simple constituent operations . class Mobile: def __init__(self, name, weight, screen_size, ram, os, camera_mp, battery): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(name=&quot;Samsung S10&quot;, weight = &quot;157g&quot;, screen_size = &quot;6.1 inch&quot;, ram = &quot;8GB&quot;, os = &quot;android 9.0&quot;, camera_mp = &quot;12 megapixel&quot;, battery = &quot;3400 mAh&quot;) . samsung_s10.show() . name: Samsung S10 weight: 157g screen_size: 6.1 inch ram: 8GB os: android 9.0 camera_mp: 12 megapixel battery: 3400 mAh . to get rid of the long list of parameters we can have the features in the main program but directly setting attributes in the client program is wrong, it goes against encapsulate what varies principle . this is prone to errors and maintenance unfriendly . class Mobile(): def __init__(self): self.name = None self.weight = None self.screen_size = None self.ram = None self.os = None self.camera_mp = None self.battery = None def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . s10 = Mobile() . s10.name = &quot;Samsung S10&quot; s10.screen_size = &quot;6.1 inch&quot;, s10.os = &quot;android 9.0&quot;, s10.camera_mp = &quot;12 megapixel&quot;, s10.battery = &quot;3400 mAh&quot; . s10.show() . name: Samsung S10 weight: None screen_size: (&#39;6.1 inch&#39;,) ram: None os: (&#39;android 9.0&#39;,) camera_mp: (&#39;12 megapixel&#39;,) battery: 3400 mAh . now the features have been encapsulated in a seperate class called MyMobile the build method instantiates a new mobile object and encapsulates setting of sttributes | . class MyMobileBuilder(): def __init__(self): self.__mobile = Mobile() def get_mobile(self): return self.__mobile def build_name(self, name): self.__mobile.name = name def build_memory(self, ram): self.__mobile.ram = ram def build_camera(self, camera_mp): self.__mobile.camera_mp = camera_mp def build_otherfeatures(self, weight, screen_size, os, battery): self.__mobile.weight = weight self.__mobile.screen_size = screen_size self.__mobile.os = os self.__mobile.battery = battery . build the mobile, get the finished product and show the features . we solved - . long parameter list problem | encapsulating attributes | . builder = MyMobileBuilder() . builder.build_name(&#39;Samsung S10&#39;) builder.build_memory(&#39;8GB&#39;) builder.build_camera(&#39;16 megapixels&#39;) . mobile = builder.get_mobile() . mobile.show() . name: Samsung S10 weight: None screen_size: None ram: 8GB os: None camera_mp: 16 megapixels battery: None . # Builder is less valuable in python, because you can specify default values class Mobile: def __init__(self, name, weight=&#39;157gm&#39;, screen_size=&#39;5inches&#39;, ram=&#39;8GB&#39;, os=&#39;Android&#39;, camera_mp=&#39;16 megapixels&#39;, battery=&#39;3400 mAh&#39;): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(&#39;Samsung S10&#39;) samsung_s10.show() . name: Samsung S10 weight: 157gm screen_size: 5inches ram: 8GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . samsung_s8 = Mobile(&#39;Samsung S8&#39;, screen_size=&#39;4.4inches&#39;, ram=&#39;4GB&#39;) samsung_s8.show() . name: Samsung S8 weight: 157gm screen_size: 4.4inches ram: 4GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . # Object Pool Pattern # Used when the cost of initializing objects is high # Number of objects in use at a time is low # Rate of object instantiation is high # Pools used to cache and manage objects # Avoid creating new objects, when an existing one is available # Reuse objects rather than incur the cost of creating one # common example: thread pools # some processes are embarrassingly parallel # threads are expensive to create and free up # use a thread pool -&gt; mitigates the overhead of pool creation # avoids needless re-instantiation and expensive acquisition of resources . class Connection: def __init__(self): self.__is_used = False # Imagine a very heavy-duty initialization process here # to set up the database connections and connect self.connect_to_database() def acquire(self): self.__is_used = True def release(self): self.__is_used = False def is_used(self): return self.__is_used def connect_to_database(self): pass . class ConnectionPool: def __init__(self, num_connections): self.__num_connections = num_connections self.__connections = [] for i in range(num_connections): self.__connections.append(Connection()) def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(3) . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253ff03aac8&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . conn_4 = pool.acquire() conn_4 is None . True . pool.release(conn_3) . conn_4 = pool.acquire() conn_4 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . pool.release(conn_2) . conn_5 = pool.acquire() conn_5 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . class ConnectionPool: __instance = None def __new__(cls, num_connections): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(ConnectionPool, cls).__new__(cls) cls.__instance.__num_connections = num_connections cls.__instance.__connections = [] for i in range(num_connections): cls.__instance.__connections.append(Connection()) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(2) . No instance exists, creating a new one . pool = ConnectionPool(2) . A previously created instance exists, returning that same one . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253feeed048&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253feeed308&gt; . conn_3 = pool.acquire() conn_3 is None . True . pool.release(conn_2) . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253feeed308&gt; . .",
            "url": "https://elydora.github.io/DataScienceBlog/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "relUrl": "/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "date": " • Jun 28, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Title",
            "content": "# model more complex real world entities # Classes -&gt; have State (Attributes) and Behavior (Perform Actions) . # class is the blueprint for an entity # each entity is known as an instance or object # each objects has its own independent existence . # keyword class Name: # attributes are called member variables # functions perform actions on the member variables -&gt; called member functions # no limit for vars/functions . # Variables: # Class variables -&gt; associated with the class itself; shared by all objects of the class # - declared outside of any method # - referred to by class name # Instance variables -&gt; associated with objects of a class; exclusive property # - declared inside any method # - referred using the self keyword . # member functions -&gt; perform actions, update state, return state . # Inheritance # tries to capture the similarities and differences in real-world entities # Portray relationships # base, parent, super class | derived, child class, subclass . # Object-oriented programming # Polymorphism - the ability of an object to behave in multiple ways # Encapsulation of data # Clear modular structure for code # Provides abstractions and data encapsulation # Easy to maintain and reuse code # Model real-world entities .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/23/classes-Introduction.html",
            "relUrl": "/2020/06/23/classes-Introduction.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Title",
            "content": "class Shape: pass class Shape(): pass class Shape(object): pass . class Shape: def __init__(self, shape_type): self.__type = shape_type def get_type(self): return self.__type . circle = Shape(&quot;circle&quot;) type(circle) . __main__.Shape . circle.get_type() . &#39;circle&#39; . square = Shape(&quot;square&quot;) type(square) . __main__.Shape . class Shape: def __init__(self, shape_type, color=&quot;Red&quot;): # optional self.__type = shape_type self.__color = color def get_type(self): return self.__type def get_color(self): return self.__color def get_area(self): pass def get_perimeter(self): pass . circle = Shape(&quot;circle&quot;) circle.get_color() . &#39;Red&#39; . class Circle(Shape): pass . circle = Circle(&quot;circle&quot;) . type(circle) . __main__.Circle . class Circle(Shape): def __init__(self): Shape.__init__(self, &quot;circle&quot;) . class Square(Shape): def __init__(self): Shape.__init__(self, &quot;square&quot;) . circle = Circle() square = Square() circle.get_type(), square.get_type() . (&#39;circle&#39;, &#39;square&#39;) . class Circle(Shape): def __init__(self, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) . circle = Circle() circle.get_color() . &#39;green&#39; . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . circle = Circle(5, color=&quot;orange&quot;) circle.get_area() . 78.53981633974483 . help(Circle) . Help on class Circle in module __main__: class Circle(Shape) | Circle(radius, color=&#39;green&#39;) | | Method resolution order: | Circle | Shape | builtins.object | | Methods defined here: | | __init__(self, radius, color=&#39;green&#39;) | Initialize self. See help(type(self)) for accurate signature. | | get_area(self) | | get_perimeter(self) | | - | Methods inherited from Shape: | | get_color(self) | | get_type(self) | | - | Data descriptors inherited from Shape: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): super().__init__(self, &quot;circle&quot;, color) # super is also possible self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . issubclass(Circle, Shape) . True . # Multiple and Multilevel Inheritance class Father: pass class Mother: pass . class Child1(Father, Mother): pass . help(Child1) . Help on class Child1 in module __main__: class Child1(Father, Mother) | Method resolution order: | Child1 | Father | Mother | builtins.object | | Data descriptors inherited from Father: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . class Father: def height(self): print(&quot;I have inherited my height from my father&quot;) class Mother: def intelligence(self): print(&quot;I have inherited my intelligence from my mother&quot;) class Child(Father, Mother): def experience(self): print(&quot;My experience are all my own&quot;) . c = Child() c.height() . I have inherited my height from my father . c.intelligence() . I have inherited my intelligence from my mother . # Polymorphism class Hominidae(): def communication(self): print(&quot;They use auditory calls and visual cues.&quot;) def walk(self): print(&quot;They are knuckle-walkers, used to hang and swing from one tree to another.&quot;) class Human(Hominidae): def communication(self): print(&quot;They use language to communicate.&quot;) def walk(self): print(&quot;They are bipeds.&quot;) class Gorilla(Hominidae): def communication(self): print(&quot;They use twenty-five distinct vocalizations to communicate.&quot;) def walk(self): print(&quot;They are knuckle-walkers.&quot;) hominidae_1 = Hominidae() human_1 = Human() gorilla_1 = Gorilla() . hominidae_1.communication() human_1.communication() gorilla_1.communication() . They use auditory calls and visual cues. They use language to communicate. They use twenty-five distinct vocalizations to communicate. . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/23/classes-Inheritance.html",
            "relUrl": "/2020/06/23/classes-Inheritance.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Title",
            "content": "# Classes as custom data types class Student: pass . object_1 = Student() . type(object_1) . __main__.Student . object_2 = Student() . object_1 . &lt;__main__.Student at 0x288a7e26148&gt; . object_2 . &lt;__main__.Student at 0x288a88928c8&gt; . isinstance(object_1, Student) . True . object_1.name = &#39;Michel&#39; object_1.email = &#39;Michel@xyz.com&#39; . object_1.name . &#39;Michel&#39; . object_1.school . AttributeError Traceback (most recent call last) &lt;ipython-input-12-68b03d9bbaba&gt; in &lt;module&gt; -&gt; 1 object_1.school AttributeError: &#39;Student&#39; object has no attribute &#39;school&#39; . object_3 = Student() object_3.name . AttributeError Traceback (most recent call last) &lt;ipython-input-13-b5626ff88877&gt; in &lt;module&gt; 1 object_3 = Student() -&gt; 2 object_3.name AttributeError: &#39;Student&#39; object has no attribute &#39;name&#39; . class Student: name = &quot;&quot; score = 0 active = True . s1 = Student() . s1.name = &quot;John&quot; s1.score = 50 s1.name, s1.score, s1.active . (&#39;John&#39;, 50, True) . # Initializing # special methods are marked with __methodname__ class Student: def __init__(self): # can be anything, but self is standard print(&#39;Initialize called!&#39;) . s1 = Student() . Initialize called! . s2 = Student() s3 = Student() . Initialize called! Initialize called! . class Student: def __init__(self, name): # can be anything, but self is standard self.name = name # self refers to the current instance self.mail = name + &quot;.&quot; + &quot;@xyz.com&quot; . s1 = Student(&quot;Felix&quot;) s1.mail . &#39;Felix.@xyz.com&#39; . del s1.mail s1.mail . AttributeError Traceback (most recent call last) &lt;ipython-input-8-0ed8e4b3810a&gt; in &lt;module&gt; 1 del s1.mail -&gt; 2 s1.mail AttributeError: &#39;Student&#39; object has no attribute &#39;mail&#39; . class Competition: # class variable raise_amount = 1.04 def __init__(self, name, prize): self.name = name self.prize = prize def raise_prize(self): self.prize = self.prize * raise_amount . debate = Competition(&#39;Debate&#39;, 500) print(debate.raise_amount) . 1.04 . Competition.raise_amount . 1.04 . debate.__dict__ . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500} . Competition.__dict__ . mappingproxy({&#39;__module__&#39;: &#39;__main__&#39;, &#39;raise_amount&#39;: 1.04, &#39;__init__&#39;: &lt;function __main__.Competition.__init__(self, name, prize)&gt;, &#39;raise_prize&#39;: &lt;function __main__.Competition.raise_prize(self)&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Competition&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Competition&#39; objects&gt;, &#39;__doc__&#39;: None}) . debate.raise_amount = 10 debate.__dict__ # new instance attribute is added . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500, &#39;raise_amount&#39;: 10} . class Competition: def __init__(self, name, prize): self.name = name self.prize = prize self.participants = [] . debate = Competition(&#39;Debate&#39;, 500) debate.participants . [] . Competition.participants . AttributeError Traceback (most recent call last) &lt;ipython-input-5-ea531b615844&gt; in &lt;module&gt; -&gt; 1 Competition.participants AttributeError: type object &#39;Competition&#39; has no attribute &#39;participants&#39; . debate.participants.append(&#39;Alice&#39;) . debate.participants . [&#39;Alice&#39;] . # instance and class variables are public by default # hack for private attributes: class Dog: def __init__(self, name, breed): self.__name = name self.__breed = breed def print_details(self): print(&#39;My name is %s and I am a %s&#39; % (self.__name, self.__breed)) . d1 = Dog(&quot;Moje&quot;, &quot;Golden Retriever&quot;) d1.print_details() . My name is Moje and I am a Golden Retriever . d1.__dict__ . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;} . d1.__name = &quot;Oba&quot; d1.print_details() # doesn&#39;t update . My name is Moje and I am a Golden Retriever . d1.__dict__ # new attribute created . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;, &#39;__name&#39;: &#39;Oba&#39;} . d1._Dog__breed = &quot;Husky&quot; # makes it harder to change, but can be changed d1.print_details() . My name is Moje and I am a Husky . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/23/classes-GettingStarted.html",
            "relUrl": "/2020/06/23/classes-GettingStarted.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Title",
            "content": "# special methods class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes rowing = Competition(&quot;Rowing&quot;, 10000) . print(rowing) . &lt;__main__.Competition object at 0x000001D68AE718C8&gt; . rowing . &lt;__main__.Competition at 0x1d68ae718c8&gt; . class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes def __repr__(self): # representation for print function, if __str__ is not defined return &quot;(&#39;{}&#39;, {})&quot;.format(self.__name, self.__prize) . archery = Competition(&quot;Archery&quot;, 8000) . print(archery) . (&#39;Archery&#39;, 8000) . str(archery) # looks for special method __str__() . &#34;(&#39;Archery&#39;, 8000)&#34; . repr(archery) . &#34;(&#39;Archery&#39;, 8000)&#34; . class Competition: def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) . archery = Competition(&quot;Archery&quot;, &quot;United Kingdom&quot;, 7500) archery . Competition: Archery held in United Kingdom, prize: 7500 . print(archery) . &#39;Archery United Kingdom - 7500&#39; . # the add method 1 + 2 . 3 . int.__add__(1, 2) . 3 . str.__add__(&quot;a&quot;, &quot;b&quot;) . &#39;ab&#39; . class Savings: def __init__(self, amount): self.__amount = amount . s1 = Savings(1000) s2 = Savings(22000) . s1 + s2 . TypeError Traceback (most recent call last) &lt;ipython-input-27-07ecabcb1b41&gt; in &lt;module&gt; -&gt; 1 s1 + s2 TypeError: unsupported operand type(s) for +: &#39;Savings&#39; and &#39;Savings&#39; . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount . s1 = Savings(1000) s2 = Savings(22000) s1 + s2 . 23000 . # sub method class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount def __sub__(self, other): return self.__amount - other.__amount . s1 = Savings(5000) s2 = Savings(457) s1 - s2 . 4543 . ## mul method 1.0 * 2.1 . 2.1 . float.__mul__(1.0, 2.1) . 2.1 . float.__mul__(1, 2.1) . TypeError Traceback (most recent call last) &lt;ipython-input-37-ee0b82aa5938&gt; in &lt;module&gt; -&gt; 1 float.__mul__(1, 2.1) TypeError: descriptor &#39;__mul__&#39; requires a &#39;float&#39; object but received a &#39;int&#39; . 10 // 3 . 3 . int.__floordiv__(10, 3) . 3 . int.__mod__(4, 2) . 0 . int.__mod__(10, 3) . 1 . int.__pow__(6, 2) . 36 . len(&quot;test&quot;) . 4 . str.__len__(&quot;test&quot;) . 4 . some_list = [1, 4, 5, 7, 2] len(some_list) . 5 . class Participants: def __init__(self): self.__participants = [] def add_participants(self, name): self.__participants.append(name) def __len__(self): return len(self.__participants) . participants = Participants() participants.add_participants(&quot;Felix&quot;) participants.add_participants(&quot;Johan&quot;) participants.add_participants(&quot;Max&quot;) . len(participants) . 3 . # Properties class Wrestler: def __init__(self): self.__name = &quot;&quot; def set_name(self, name): print(&quot;setter method called&quot;) self.__name = name def get_name(self): print(&quot;getter method called&quot;) return self.__name def del_name(self): del self.__name name = property(get_name, set_name, del_name) . w = Wrestler() . w.name = &quot;Kart&quot; . setter method called . w.name . getter method called . &#39;Kart&#39; . # Properties with Decorators class WrestlerNew: def __init__(self, name): self.__name = name @property # this is the method for accessing def name(self): print(&quot;getter method called&quot;) return self.__name @name.setter # this is the method for setting new vals def name(self, value): print(&quot;setter method called&quot;) self.__name = value @name.deleter def name(self): del self.__name . w1 = WrestlerNew(&quot;Rey&quot;) . w1.name . getter method called . &#39;Rey&#39; . # Class Methods / Static Methods class Competition: __raise_amount = 1.04 # class variable def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def raise_prize(self): self.__prize = self.__prize * self.__raise_amount def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) @classmethod def get_raise_amount(cls): return cls.__raise_amount @classmethod def set_raise_amount(cls, amount): cls.__raise_amount = amount . c1 = Competition(&quot;Running&quot;, &quot;Germany&quot;, 50000) . c1.set_raise_amount(2) . c1.get_raise_amount() . 2 . Competition.get_raise_amount() . 2 . class Rectangle: @staticmethod # cannot access class variables def area(x,y): return x * y . Rectangle.area(5,5) . 25 . from abc import ABC, abstractmethod class Hominidae(): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . chimpanzee = Hominidae() chimpanzee.behavior() . Blabla . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . paul = Human() paul.diet() . Omnivorous . class Hominidae(ABC): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h = Hominidae() . h.behavior() . Blabla . h.diet() . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . myra = Human() myra.diet() myra.walk() . Omnivorous Bipeds . class Hominidae(ABC): @abstractmethod # how to do it def diet(self): pass @abstractmethod def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h1 = Hominidae() . TypeError Traceback (most recent call last) &lt;ipython-input-131-df612faa022d&gt; in &lt;module&gt; -&gt; 1 h1 = Hominidae() TypeError: Can&#39;t instantiate abstract class Hominidae with abstract methods diet, walk . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/23/classes-Advanced-Functionality.html",
            "relUrl": "/2020/06/23/classes-Advanced-Functionality.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Title",
            "content": "# Time complexity def addition(num1, num2): total = num1 + num2 print(&quot;The sum of %d and %d is %d&quot; %(num1, num2, total)) . addition(10, 4) . The sum of 10 and 4 is 14 . def addition(num1, num2): num_iterations = 0 total = num1 + num2 num_iterations += 1 print(&quot;The sum of %d and %d is %d n total number: %d&quot; %(num1, num2, total, num_iterations)) . addition(50,10) # O(1) operation, number of operations is constant, no matter the input . The sum of 50 and 10 is 60 total number: 1 . # O(N) operations -&gt; linear ascend, number of operations depends on the input value def check_prime1(number): num_iterations = 0 for i in range(2, number): num_iterations += 1 if number%i == 0: print(&quot;%d is not a prime number n Total number of iterations = %d&quot; %(number, num_iterations)) return print(&quot;%d is a prime number nTotal number of iterations = %d&quot; %(number, num_iterations)) . check_prime1(10) . 10 is not a prime number Total number of iterations = 1 . check_prime1(50) . 50 is not a prime number Total number of iterations = 1 . check_prime1(1) . 1 is a prime number Total number of iterations = 0 . check_prime1(49) . 49 is not a prime number Total number of iterations = 6 . check_prime1(191) . 191 is a prime number Total number of iterations = 189 . # Another example: checking for a maximum value in a list, # that takes longer, if the input list gets longer . #O(n*n) operations def print_pairs(number_list): num_iterations = 0 n = len(number_list) for i in range(n): for j in range(n): print(number_list[i], number_list[j]) num_iterations += 1 print(&quot;Total iterations are %d&quot; % num_iterations) . print_pairs([123,67]) . 123 123 123 67 67 123 67 67 Total iterations are 4 . print_pairs([123,67, 25, 79]) . 123 123 123 67 123 25 123 79 67 123 67 67 67 25 67 79 25 123 25 67 25 25 25 79 79 123 79 67 79 25 79 79 Total iterations are 16 . # number of iterations is equal to the square of the input size - complexity is O(n^2) . #Built-in queue from queue import Queue olympics = Queue(5) olympics . &lt;queue.Queue at 0x2e919de0708&gt; . olympics.put(&quot;United Statues(USA)&quot;) olympics.put(&quot;Great Britain(GBR)&quot;) . olympics.empty() # O(1) . False . olympics.full() # O(1) . False . olympics.qsize() # O(1) . 2 . olympics.put(&quot;China(CHN)&quot;) olympics.put(&quot;Russia(RUS)&quot;) olympics.put(&quot;Germany(GER)&quot;) . olympics.full() . True . olympics.qsize() . 5 . olympics.get() . &#39;United Statues(USA)&#39; . olympics.qsize() . 4 . olympics.full() . False . # Stack stack = [] stack.append(&quot;United States&quot;) stack.append(&quot;Great Britain&quot;) stack.append(&quot;China&quot;) . stack . [&#39;United States&#39;, &#39;Great Britain&#39;, &#39;China&#39;] . stack.pop() . &#39;China&#39; . # Linked lists class Node: def __init__(self, dataval=None, nextval=None): self.dataval = dataval self.nextval = nextval def __repr__(self): return repr(self.dataval) class LinkedList: def __init__(self): self.head = None def __repr__(self): # O(N) nodes = [] curr = self.head while curr: nodes.append(repr(curr)) curr = curr.nextval return &quot;[&quot; + &quot;-&gt;&quot;.join(nodes) + &quot;]&quot; def prepend(self, dataval): # O(1) self.head = Node(dataval=dataval, nextval = self.head) def append(self, dataval): if not self.head: self.head = Node(dataval=dataval) return curr = self.head while curr.nextval: curr = curr.nextval curr.nextval = Node(dataval=dataval) def add_after(self, middle_dataval, dataval): if middle_dataval is None: print(&quot;Data to insert after not specified&quot;) return curr = self.head while curr and curr.dataval != middle_dataval: curr = curr.nextval new_node = Node(dataval = dataval) new_node.nextval = curr.nextval curr.nextval = new_node def find(self, data): curr = self.head while curr and curr.dataval != data: curr = curr.nextval return curr def remove(self, data): curr = self.head prev = None while curr and curr.dataval != data: prev = curr curr = curr.nextval if prev is None: self.head = curr.nextval elif curr: prev.nextval = curr.nextval curr.nextval = None def reverse(self): curr = self.head prev_node = None next_node = None while curr: nextval = curr.nextval curr.nextval = prev_node prev_node = curr curr = nextval self.head = prev_node . numbers = LinkedList() . numbers . [] . numbers.append(&quot;two&quot;) numbers.append(&quot;three&quot;) numbers . [&#39;two&#39;-&gt;&#39;three&#39;] . numbers.prepend(&quot;one&quot;) numbers . [&#39;one&#39;-&gt;&#39;two&#39;-&gt;&#39;three&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/22/Implementing-Data-Structures.html",
            "relUrl": "/2020/06/22/Implementing-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Title",
            "content": "# make common operations fast (fast loading / unloading of complex objects) # make difficult operations possible # occupy less space and still represent the complexity of information and # its interrelationships in an intuitive way # data structures and algorithms go hand-in-hand # A set is extremely fast for membership and containment queries # stacks can be used for undo functionality in applications as well as back functionality # index data structures # hash tables # graphs for relationships # data structures are concrete representations of data from the point of view of an implementor # they specify the actual implementation of the structure in code to meet the expected behavior . Hallo . # Measuring Performance metrics: # Time (# of operations / amount of processing) # Space (make best use of available space, memory and disk space needed) # Network (overall network bandwidth, network speed) # efficient = uses fewer resources along all these axes # using more of the resources that are plenty, and less of those who lack # performance indicates how much of these resources are used by the code # == Performance can be measured in terms of complexity # Complexity is a measure of how resource requirements change as the size of the problem gets larger # The higher the complexity of a overall problem, the lower the performance . 2 . # Basic Operations # Read - Write - Assignment - Test # do not worry about the number of operations # be worried how that number changes is based on the input size # that is how performance changes based on input size # focus on the worst case performance # what is the maximum number of basic operations that might have to be performed based on the input # Complexity varies with the algorithm . # Big-O Notation # Represents the complexity of an algorithm # An algorithm whose complexity does not change with the input size is O(1) # -&gt; the algorithm is said to have constant time complexity # The algorithm is said to have constant time complexity # It takes the same amount of time, even if the input size is doubled, tripled, or increased to any level . # The complexity of an algorithm is O(N) if the time taken by the algorithm increases linearly when N increases # The complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases # Lower order terms and constants do not matter while expressing complexity # O(N^2 + 1000) is equivalent to O(N^2) -&gt; N is assumed very large # O(N^2+N) is equivalent to O(N^2) . # Fastest O(1) &lt; O(N) &lt; O(N^2) &lt; O(N^3) Slowest . # Linked Lists: [Data|Pointer]; Pointer points to the next element, or null # Header points to the first element # Best way to count is to increment/decrement a counter at every list operation # Adding: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Deleting: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Counting: Iterating -&gt; O(1), Increment/Decrement a permanent Counter -&gt; O(1) # Reversing: O(N) . # Stacks: # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # LIFO principle # Insertion and deletion at the same end . # Queues: # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # FIFO principle # Insertion and deletion at opposite ends . # Peek - Value of the most recently inserted element .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/22/Fundamental-Data-Structures.html",
            "relUrl": "/2020/06/22/Fundamental-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Title",
            "content": "empty_list = [] empty_list . list_str=[&quot;Toyota&quot;,&quot;VW&quot;,&quot;BMW&quot;,&quot;Mercedes&quot;] list_str . list_bool=[True, False, False, True] list_bool . list_str[1] . list_str[len(list_str)-1] . list_str[-1] . list_str[0] = &quot;Hyundai&quot; list_str . list_str.append(&quot;Opel&quot;) list_str . list_str += [&#39;Dacia&#39;, &#39;Ford&#39;] list_str . list_str.sort() list_str . list_str.reverse() list_str . list_str.pop() list_str . list_str.count(&quot;Dacia&quot;) . print(list_str) . new_list = list_str.copy() list_str.clear() list_str . del list_str . list_2 = sorted(new_list) # whole new list . any([0]) # greater 0 . any([0, 1]) . all([0,1]) . new_list[0:2] # creates a deep copy . new_list[0:100] . new_list[1:] . new_list[:3] . new_list[:-1] . new_list[-4:-1] . new_list[0:5:2] . &quot;Dacia&quot; in new_list . new_list[::-3] . new_list[100] . new_list.count() .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/21/comp-dt-ListsAndTuples.html",
            "relUrl": "/2020/06/21/comp-dt-ListsAndTuples.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Title",
            "content": "# Introducing Dictionaries empty_dict = {} empty_dict . {} . bike_owners = {&quot;James&quot;:&quot;Ducati Monster 1200&quot;, &quot;Jacob&quot;:&quot;Ducati Scrambler 1100&quot;} bike_owners . {&#39;James&#39;: &#39;Ducati Monster 1200&#39;, &#39;Jacob&#39;: &#39;Ducati Scrambler 1100&#39;} . bike_owners[&quot;Jacob&quot;] . &#39;Ducati Scrambler 1100&#39; . int_dict = {1:45, 2:55, 3:65} int_dict[1] . 45 . int_dict.keys() . dict_keys([1, 2, 3]) . 1 in int_dict.keys() . True . mixed_dict = {False: &quot;Daniel&quot;, &quot;Aria&quot;:[1,2,3], &quot;Jacob&quot;:True} mixed_dict . {False: &#39;Daniel&#39;, &#39;Aria&#39;: [1, 2, 3], &#39;Jacob&#39;: True} . mixed_dict[False] . &#39;Daniel&#39; . int_dict[1] = 78 int_dict . {1: 78, 2: 55, 3: 65} . del int_dict[3] int_dict . {1: 78, 2: 55} . # Complex data types in python fruits = { &quot;Banana&quot;:[50,60,75,99], &quot;Apple&quot;:[48,86,47,25], &quot;Strawberries&quot;:[70,80,60,65] } print(fruits[&quot;Banana&quot;]) print(fruits[&quot;Banana&quot;][3]) fruits[&quot;Banana&quot;][3]=50 print(fruits[&quot;Banana&quot;][3]) . [50, 60, 75, 99] 99 50 . fruit_qtc_consumed = { &quot;Banana&quot;: {&quot;Fri&quot;:90, &quot;Mo&quot;:80, &quot;Di&quot;:90}, &quot;Apple&quot;:{&quot;Fri&quot;:10, &quot;Mo&quot;:12, &quot;Di&quot;:13}, &quot;Strawberry&quot;:{&quot;Fri&quot;:47, &quot;Mo&quot;:48, &quot;Di&quot;:20}, } print(fruit_qtc_consumed[&quot;Strawberry&quot;]) print(fruit_qtc_consumed[&quot;Strawberry&quot;][&quot;Fri&quot;]) . {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20} 47 . len(fruit_qtc_consumed) . 3 . len(fruit_qtc_consumed.keys()) . 3 . sorted(fruit_qtc_consumed) . [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Strawberry&#39;] . sorted(fruit_qtc_consumed, reverse=True) . [&#39;Strawberry&#39;, &#39;Banana&#39;, &#39;Apple&#39;] . # return key value pairs fruit_qtc_consumed.items() . dict_items([(&#39;Banana&#39;, {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}), (&#39;Apple&#39;, {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}), (&#39;Strawberry&#39;, {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20})]) . copy = fruit_qtc_consumed.copy() copy . {&#39;Banana&#39;: {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}, &#39;Apple&#39;: {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}, &#39;Strawberry&#39;: {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20}} . copy.pop(&quot;Banana&quot;) . {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90} . persons1 = {&quot;Ethan&quot;:45,&quot;Monica&quot;:88,&quot;Max&quot;:10} persons2 = {&quot;Ethan&quot;:46,&quot;Claus&quot;:47,&quot;Rainer&quot;:44} print(persons1) persons1.update(persons2) print(persons1) . {&#39;Ethan&#39;: 45, &#39;Monica&#39;: 88, &#39;Max&#39;: 10} {&#39;Ethan&#39;: 46, &#39;Monica&#39;: 88, &#39;Max&#39;: 10, &#39;Claus&#39;: 47, &#39;Rainer&#39;: 44} . persons2.clear() persons2 . {} . del persons2 . # Sets set_string = {&quot;Emma&quot;, &quot;Olivia&quot;, &quot;Ava&quot;, &quot;Mia&quot;} set_string . {&#39;Ava&#39;, &#39;Emma&#39;, &#39;Mia&#39;, &#39;Olivia&#39;} . print(set_string) # no intrinsic ordering . {&#39;Ava&#39;, &#39;Mia&#39;, &#39;Emma&#39;, &#39;Olivia&#39;} . empty_set = set() . mixed_set = {&quot;Emmma&quot;, 5, 1.5, True,(1,2,3,4)} #Lists are not allowed . student_set = {&quot;Emma&quot;, &quot;Marc&quot;, &quot;Janine&quot;, &quot;Emma&quot;} student_set # duplicates are eliminated . {&#39;Emma&#39;, &#39;Janine&#39;, &#39;Marc&#39;} . student_set[1] . TypeError Traceback (most recent call last) &lt;ipython-input-35-a8e02497ae7e&gt; in &lt;module&gt; -&gt; 1 student_set[1] 2 3 TypeError: &#39;set&#39; object is not subscriptable . student_set.add(&quot;Felix&quot;) . len(student_set) . 4 . max(student_set) . &#39;Marc&#39; . student_set.remove(&quot;Felix&quot;) student_set.discard(&quot;Felix&quot;) . number1={1,2,3,4,5} number2={4,5,6,7,8} number3={7,8,9,10,11} . number1.union(number2) . {1, 2, 3, 4, 5, 6, 7, 8} . number1.difference(number2) . {1, 2, 3} . number1.isdisjoint(number2) . False . number1.isdisjoint(number3) . True . # Nested Lists car_matrix = [[&quot;Hennessey Venom GT&quot;, 1244], [&quot;SSC Ultimate Aero&quot;, 1287], [&quot;Zenvo ST1&quot;, 1100]] car_matrix . [[&#39;Hennessey Venom GT&#39;, 1244], [&#39;SSC Ultimate Aero&#39;, 1287], [&#39;Zenvo ST1&#39;, 1100]] . len(car_matrix) . 3 . len(car_matrix[1]) . 2 . car_matrix[1][0] . &#39;SSC Ultimate Aero&#39; . car_matrix[1] . [&#39;SSC Ultimate Aero&#39;, 1287] . car_matrix[1][0:2] . [&#39;SSC Ultimate Aero&#39;, 1287] . # Conversion of Lists my_list = [&quot;Leo&quot;,18,&quot;Aaron&quot;,15,&quot;Max&quot;,25,&quot;Sofi&quot;,22,&quot;Marques&quot;,2,&quot;Julia&quot;,91,] print(my_list) print(tuple(my_list)) # tuple is immutable . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] (&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91) . my_list1 = [[&quot;Leo&quot;,18],[&quot;Aaron&quot;,48],[&quot;Max&quot;,25],[&quot;Sofi&quot;,22],[&quot;Marques&quot;,2],[&quot;Julia&quot;,91]] tuple(my_list1) . ([&#39;Leo&#39;, 18], [&#39;Aaron&#39;, 48], [&#39;Max&#39;, 25], [&#39;Sofi&#39;, 22], [&#39;Marques&#39;, 2], [&#39;Julia&#39;, 91]) . d_list = dict(my_list1) names = list(d_list) names . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] . d_list2 = dict(my_list1) names2 = list(d_list2.values()) names2 . [18, 48, 25, 22, 2, 91] . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "relUrl": "/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Title",
            "content": "old_str = &quot;Python&quot; old_str . &#39;Python&#39; . new_str = old_str print(old_str) print(new_str) . Python Python . new_str[2] = &quot;T&quot; . TypeError Traceback (most recent call last) &lt;ipython-input-3-b6e8ff6bdf2e&gt; in &lt;module&gt; -&gt; 1 new_str[2] = &#34;T&#34; TypeError: &#39;str&#39; object does not support item assignment . import copy . first_str = &quot;Will&quot; second_str = copy.copy(first_str) print(first_str) print(second_str) . Will Will . second_str = &quot;Smith&quot; print(first_str) print(second_str) . Will Smith . first_str = &quot;Johnny&quot; second_str = copy.deepcopy(first_str) # the same print(first_str) print(second_str) . Johnny Johnny . second_str = &quot;Depp&quot; print(first_str) print(second_str) . Johnny Depp . names = [&quot;Jan&quot;, &quot;Felix&quot;, &quot;Ralph&quot;] second_names = names . second_names[1] = &quot;Maria&quot; print(names) print(second_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . third_names = copy.copy(names) third_names[0] = &quot;Julia&quot; print(names) print(third_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Julia&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "relUrl": "/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Title",
            "content": "country = &quot;USA&quot; def some_fn(): print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): country = &quot;India&quot; print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): global country country = &quot;Bangladesh&quot; print(country) some_fn() . country . # passing by reference, because not reassigned and complex data type fruits_list = [&quot;Apple&quot;, &quot;Grapes&quot;, &quot;Mango&quot;, &quot;Bananas&quot;] def change_list(fruits_list): fruits_list[0] = &quot;Kiwi&quot; fruits_list = [&quot;Kiwi&quot;] # does nothing on the outside print(&quot;Inside the function: &quot;, fruits_list) change_list(fruits_list) print() print(&quot;Outside the function: &quot;, fruits_list) . help(&quot;modules&quot;) . import math . print(math.pi) . math.e . math.ceil(8.1) . math.floor(8.1) . math.pow(2,4) . math.sqrt(24) . import os . os.getcwd() . os.environ . user = os.environ[&quot;USERNAME&quot;] user . os.environ[&quot;PATH&quot;] . os.listdir() . os.listdir(&quot;.&quot;) . os.path.isdir(os.environ[&quot;PATH&quot;]) . os.path.isfile(os.environ[&quot;PATH&quot;]) . import random . random.random() . random.random() . random.randint(0, 10) . listA = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] random.choice(listA) . import datetime datetime.date.today() . datetime.datetime.now() . def hello(name): print(&quot;Hello!&quot;, name) hello(&quot;Bruce&quot;) . hello . greet = hello . greet(&quot;Max&quot;) . calculate_length = len calculate_length(&quot;SomeString&quot;) . calculate_length == len . import math def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) def diameter_circle_fn(r): pass calculate(10, fn=diameter_circle_fn) . def area_rectangle_fn(length, breadth): return length * breadth def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) calculate(20, 40, fn=area_rectangle_fn) . # lambdas - functions without names def square(x): return x * x . result = square(5) result . square . sq = square . result = sq(12) result . cube_of = lambda x: x * x * x result = cube_of(3) result . cube_of . add = lambda x, y: x + y . result = add(5, 10) result . (lambda x: x + 2)(10) . (lambda x:x * 10)(22) . def check_if_even(x): assert x % 2 == 0 . check_if_even(2) . check_if_even(3) . # no keywords in a lambda even_check_lambda = lambda x : assert x % 2 == 0 . total_score = lambda math, physics, chemistry, biology=50: math+physics+chemistry+biology . total_score(math=50, physics=10, chemistry=23) . (lambda **num_dictionary: sum(num_dictionary.values()))(a=23, b=34, c=45) . # lambda filter num_list = [1,5,6,7,11,78,99,34,105,214] . filter(lambda x: x &gt; 10, num_list) . greater_than_10_list = list(filter(lambda x: x &gt; 10, num_list)) greater_than_10_list . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/20/functions-general.html",
            "relUrl": "/2020/06/20/functions-general.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Title",
            "content": "Functions - Advanced . toc: true badges: true comments: true sticky_rank: 1 author: Jeremy Howard &amp; Hamel Husain categories: [fastpages, jupyter] . # Recursion - Invoking Functions - Invoking a function from within itself def hello(name): print(&quot;Hello&quot;, name) hello(name) #hello(&quot;Ron&quot;) . import sys sys.getrecursionlimit() . 3000 . def increment(num): print(num, end = &quot; &quot;) increment(num + 1) return #increment(1) . def decrement(num): while num &gt; 0: print(num) num = num - 1 decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def decrement(num): if num == 0: return print(num) decrement(num - 1) decrement(10) . 10 9 8 7 6 5 4 3 2 1 . # Generators - create a sequence that can be iterated over def generator(): print(&quot;One!&quot;) yield 1 # control execution flow print(&quot;Two!&quot;) yield 2 print(&quot;Three!&quot;) yield 3 g = generator() # no code execution g . &lt;generator object generator at 0x000001A6BE9FBCC8&gt; . next(g) # execute g until the first yield statement . One! . 1 . next(g) # second yield statement . Two! . 2 . next(g) # until third statement . Three! . 3 . next(g) . StopIteration Traceback (most recent call last) &lt;ipython-input-20-e734f8aca5ac&gt; in &lt;module&gt; -&gt; 1 next(g) StopIteration: . g2 = generator() g . next(g2) . def generator(): print(&quot;One!&quot;) n = 1 yield n # control execution flow print(&quot;Two!&quot;) n += 1 yield n print(&quot;Three!&quot;) n += 1 yield n g3 = generator() . next(g3) . next(g3) . def generate_even_numbers(limit): for i in range(0, limit, 2): yield i . g = generate_even_numbers(7) . next(g) . next(g) . next(g) . next(g) . next(g) . g2 = generate_even_numbers(20) g2_list = list(g2) . g2_list . def generate_powers_of_two(): num = 0 while True: num = num + 1 yield 2 ** num . g = generate_powers_of_two() . next(g) . next(g) . # Closures - Function in a function def nested_hello_fn(): def hello(): print(&quot;Hello Cathy!&quot;) hello() . nested_hello_fn() . hello() . def get_hello_fn(): # every closure has its own local state (do not share local variables) def hello(): print(&quot;Hello Cathy!&quot;) return hello . hello_fn = get_hello_fn() . hello_fn() . # decorators : add functionality without modifying the code itself def print_message(): print(&quot;Yohoo! Decorators are cool!&quot;) . print_message() . import random def highlight(): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) print_message() print(annotate * 50) highlight() . def make_highlighted(func): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) func() print(annotate * 50) make_highlighted(print_message) . @make_highlighted # that&#39;S how they are really used def print_a_message(): print(&quot;Now you&#39;ll see how decorators are used&quot;) print_a_message . def plus_highlight(func): def highlight(): print(&quot;+&quot;*50) func() print(&quot;+&quot;*50) return highlight def asterisk_highlight(func): def highlight(): print(&quot;*&quot;*50) func() print(&quot;*&quot;*50) return highlight @plus_highlight @asterisk_highlight def hello(): print(&quot;hello!&quot;) hello() . .",
            "url": "https://elydora.github.io/DataScienceBlog/2020/06/20/functions-advanced.html",
            "relUrl": "/2020/06/20/functions-advanced.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://elydora.github.io/DataScienceBlog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://elydora.github.io/DataScienceBlog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://elydora.github.io/DataScienceBlog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}