{
  
    
        "post0": {
            "title": "Plotly test",
            "content": "from IPython.display import HTML, display import plotly.express as px import altair as alt df = px.data.iris() display(df.head()) fig = px.scatter(df, x=&quot;sepal_width&quot;, y=&quot;sepal_length&quot;) . sepal_length sepal_width petal_length petal_width species species_id . 0 5.1 | 3.5 | 1.4 | 0.2 | setosa | 1 | . 1 4.9 | 3.0 | 1.4 | 0.2 | setosa | 1 | . 2 4.7 | 3.2 | 1.3 | 0.2 | setosa | 1 | . 3 4.6 | 3.1 | 1.5 | 0.2 | setosa | 1 | . 4 5.0 | 3.6 | 1.4 | 0.2 | setosa | 1 | . alt.Chart(df).mark_point().encode( x=&#39;sepal_width&#39;, y=&#39;sepal_length&#39; ) .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/pandas/numpy/2021/03/11/PLOTLY.html",
            "relUrl": "/ibm/data_science/pandas/numpy/2021/03/11/PLOTLY.html",
            "date": " • Mar 11, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Data Science Basics Intro",
            "content": "import yfinance as yf import pandas as pd import requests from bs4 import BeautifulSoup # import plotly.graph_objects as go # from plotly.subplots import make_subplots # from IPython.display import HTML # # def make_graph(stock_data, revenue_data, stock): # fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=(&quot;Historical Share Price&quot;, &quot;Historical Revenue&quot;), vertical_spacing = .3) # fig.add_trace(go.Scatter(x=pd.to_datetime(stock_data.Date, infer_datetime_format=True), y=stock_data.Close.astype(&quot;float&quot;), name=&quot;Share Price&quot;), row=1, col=1) # fig.add_trace(go.Scatter(x=pd.to_datetime(revenue_data.Date, infer_datetime_format=True), y=revenue_data.Revenue.astype(&quot;float&quot;), name=&quot;Revenue&quot;), row=2, col=1) # fig.update_xaxes(title_text=&quot;Date&quot;, row=1, col=1) # fig.update_xaxes(title_text=&quot;Date&quot;, row=2, col=1) # fig.update_yaxes(title_text=&quot;Price ($US)&quot;, row=1, col=1) # fig.update_yaxes(title_text=&quot;Revenue ($US Millions)&quot;, row=2, col=1) # fig.update_layout(showlegend=False, # height=900, # title=stock, # xaxis_rangeslider_visible=True) # fig2 = fig.to_html() # HTML(fig2) . tsla = yf.Ticker(&#39;TSLA&#39;) tesla_data = tsla.history(period=&#39;max&#39;) tesla_data.reset_index(inplace=True) tesla_data.head() . Date Open High Low Close Volume Dividends Stock Splits . 0 2010-06-29 | 3.80 | 5.00 | 3.51 | 4.78 | 93831500 | 0 | 0.0 | . 1 2010-06-30 | 5.16 | 6.08 | 4.66 | 4.77 | 85935500 | 0 | 0.0 | . 2 2010-07-01 | 5.00 | 5.18 | 4.05 | 4.39 | 41094000 | 0 | 0.0 | . 3 2010-07-02 | 4.60 | 4.62 | 3.74 | 3.84 | 25699000 | 0 | 0.0 | . 4 2010-07-06 | 4.00 | 4.00 | 3.17 | 3.22 | 34334500 | 0 | 0.0 | . url = &#39;https://www.macrotrends.net/stocks/charts/TSLA/tesla/revenue&#39; html_data = requests.get(url).text soup = BeautifulSoup(html_data,&quot;html5lib&quot;) tesla_revenue = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Revenue&#39;]) quarterly = soup.findAll(&quot;table&quot;)[1].find(&quot;tbody&quot;) for row in quarterly.find_all(&quot;tr&quot;): col = row.find_all(&quot;td&quot;) date = col[0].text revenue = col[1].text.replace(&quot;$&quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;) tesla_revenue = tesla_revenue.append({&quot;Date&quot;:date, &quot;Revenue&quot;:revenue}, ignore_index=True) tesla_revenue.head() tesla_revenue.dropna(inplace=True) tesla_revenue = tesla_revenue[tesla_revenue[&#39;Revenue&#39;] != &quot;&quot;] tesla_revenue.tail() . Date Revenue . 41 2010-09-30 | 31 | . 42 2010-06-30 | 28 | . 43 2010-03-31 | 21 | . 45 2009-09-30 | 46 | . 46 2009-06-30 | 27 | . import altair as alt alt.Chart(tesla_revenue).mark_line().encode( x=&#39;Revenue&#39;, y=&#39;Date:T&#39; ) # make_graph(tesla_data, tesla_revenue, &#39;Tesla Stock Data&#39;) .",
            "url": "https://elydora.github.io/DataScienceBlog/ibm/data_science/pandas/numpy/2021/03/10/IBM-DS-BASICS.html",
            "relUrl": "/ibm/data_science/pandas/numpy/2021/03/10/IBM-DS-BASICS.html",
            "date": " • Mar 10, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Creational Design Patterns",
            "content": "# a class of which only a single instance can exist # Ensure a class is instantiated only once, and provide a global point of access to it # When: # - no clear owner of the object, i. e. a global object (e. g. logger) # - when you want to use lazy instantiation # - when you need a single global way to access the object # python offers a global object pattern . class Logger: __instance = None def __init__(self): raise RuntimeError(&#39;Call get_instance() instead&#39;) @classmethod def get_instance(cls): if cls.__instance is None : print(&#39;No instance exists, creating a new one&#39;) cls.__instance = cls.__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger1 = Logger.get_instance() logger1 . logger2 = Logger.get_instance() . logger2 . # new is always called first -&gt; it creates the instance, cls is reference to not yet existing instance # init is used to initialize the existing instance -&gt; self is a reference to the instance class PythonicLogger: __instance = None def __init__(self): print(&#39;Object initialized&#39;) # put your custom code here # is called every time - could be expensive def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(PythonicLogger, cls).__new__(cls) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger3 = PythonicLogger() logger3 . logger4 = PythonicLogger() logger4 . class SuperLogger: __instance = None def __new__(cls): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(SuperLogger, cls).__new__(cls) # Place all initialization code here else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance . logger5 = SuperLogger() logger5 . logger6 = SuperLogger() logger6 . logger5 == logger6 . # Global Objects which expose methods import logger . logger.INFO . logger.WARNING . file_logger = logger.FILE_LOGGER file_logger.log(&quot;logging message&quot;) . # Separate the creation of objects from their use # Class creation or Object creation # Class-creation patterns use inheritance # Object-creation patterns use delegation # Factory method is specified in base class, implemented in derived classes # Creates an instance of several derived classes # Define an interface for creating an object, but let subclasses decide which class to instantiate # Used to postpone instantiation - responsibility passes from base class to derived classes # Factory method -&gt; create an instance of any of many derived classes # Abstract F. pattern -&gt; create an instance of any one of many families of derived classes # Abstract Factory: create instances of several families of classes # encapsulate platform dependencies # Use case: Working with Oracle or MS-SQL databases -&gt; each represents a family of classes # Microsoft Factory | Oracle Factory . class Product: def __init__(self, name, price): self.__name = name self.__price = price def get_price(self): return self.__price . class MacBookAir(Product): def __init__(self, memory, os): Product.__init__(self, &#39;MacBookAir&#39;, 1031) self.__memory = memory self.__os = os class AppleIPad(Product): def __init__(self, generation): Product.__init__(self, &#39;AppleIPad&#39;, 529) self.__generation = generation class AppleIWatch(Product): def __init__(self): Product.__init__(self, &#39;AppleIWatch&#39;, 264) . class ProductFactory(): @staticmethod def create(item_name, *args): if item_name == &#39;MacBookAir&#39;: return MacBookAir(*args) elif item_name == &#39;AppleIPad&#39;: return AppleIPad(*args) elif item_name == &#39;AppleIWatch&#39;: return AppleIWatch(*args) . air = ProductFactory.create(&#39;MacBookAir&#39;, &#39;16GB&#39;, &#39;Sierra&#39;) air.__dict__ . ipad = ProductFactory.create(&#39;AppleIPad&#39;, &#39;2nd&#39;) ipad.__dict__ . iwatch = ProductFactory.create(&#39;AppleIWatch&#39;) iwatch.__dict__ . https://realpython.com/factory-method-python/ . import json import xml.etree.ElementTree as et class Movie: def __init__(self, movie_id, name, director): self.movie_id = movie_id self.name = name self.director = director . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) elif fmt == &#39;XML&#39;: movie_info = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_info, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_info, &#39;director&#39;) director.text = movie.director return et.tostring(movie_info, encoding=&#39;unicode&#39;) else: raise ValueError(fmt) . movie = Movie(&#39;578&#39;, &#39;Avengers:End Game&#39;, &#39;Russo brothers&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . serializer.serialize(movie, &#39;YAML&#39;) . Complex logical code uses if/elif/else structures to change the behavior of an application. Using if/elif/else conditional structures makes the code harder to read, harder to understand, and harder to maintain. . When a new format is introduced: The method will have to change to implement the serialization to that format. . | When the movie object changes: Adding or removing properties to the Song class will require the implementation to change in order to accommodate the new structure. . | When the string representation for a format changes (plain JSON vs JSON API): The .serialize() method will have to change if the desired string representation for a format changes because the representation is hard-coded in the .serialize() method implementation. . | . Refactoring Code Into the Desired Interface . class MovieSerializer: def serialize(self, movie, fmt): if fmt == &#39;JSON&#39;: return self._serialize_to_json(movie) elif fmt == &#39;XML&#39;: return self._serialize_to_xml(movie) else: raise ValueError(format) def _serialize_to_json(self, movie): movie_info = { &#39;id&#39;: movie.movie_id, &#39;name&#39;: movie.name, &#39;director&#39;: movie.director } return json.dumps(movie_info) def _serialize_to_xml(self, movie): movie_element = et.Element(&#39;movie&#39;, attrib={&#39;id&#39;: movie.movie_id}) name = et.SubElement(movie_element, &#39;name&#39;) name.text = movie.name director = et.SubElement(movie_element, &#39;director&#39;) director.text = movie.director return et.tostring(movie_element, encoding=&#39;unicode&#39;) . serializer = MovieSerializer() . serializer.serialize(movie, &#39;JSON&#39;) . serializer.serialize(movie, &#39;XML&#39;) . . Provide an interface for creating families of related or dependent objects without specifying their concrete classes. . An abstract factory is a factory that returns factories.A normal factory can be used to create sets of related objects. An abstract factory returns factories. Thus, an abstract factory is used to return factories that can be used to create sets of related objects. . When the system needs to be independent of how its object are created, composed, and represented. | When the family of related objects has to be used together, then this constraint needs to be enforced. | When you want to provide a library of objects that does not show implementations and only reveals interfaces. | When the system needs to be configured with one of a multiple family of objects. | . import abc . create an interface for Toys and color . class Toy(metaclass=abc.ABCMeta): @abc.abstractmethod def show(self): pass class Color(metaclass=abc.ABCMeta): @abc.abstractmethod def show_color(self): pass . class Car(Toy): def show(self): print(&quot;Remote controlled car&quot;) class ActionFigure(Toy): def show(self): print(&quot;Captain America action figure&quot;) class ConstructionToy(Toy): def show(self): print(&quot;Lego&quot;) . class Red(Color): def show_color(self): print(&quot;red&quot;) class Green(Color): def show_color(self): print(&quot;green&quot;) class Blue(Color): def show_color(self): print(&quot;blue&quot;) . car = Car() red = Red() red.show_color(), car.show() . red Remote controlled car . (None, None) . lego = ConstructionToy() green = Green() green.show_color(), lego.show() . green Lego . (None, None) . class AbstractFactory(metaclass=abc.ABCMeta): @abc.abstractmethod def get_color(self): pass @abc.abstractmethod def get_toy(self): pass . Create concrete classes implementing the same interface. . create Factory classes extending AbstractFactory . class ColorfulToysFactory(AbstractFactory): def get_toy(self, toy_type): if toy_type == None: return None if toy_type == &quot;car&quot;: return Car() elif toy_type == &quot;action figure&quot;: return ActionFigure() elif toy_type == &quot;construction toy&quot;: return ConstructionToy() return None def get_color(self, color_type): if color_type == None: return None if color_type == &quot;red&quot;: return Red() elif color_type == &quot;green&quot;: return Green() elif color_type == &quot;blue&quot;: return Blue() return None . RED_CAR = &#39;red_car&#39; BLUE_LEGO = &#39;blue_lego&#39; GREEN_ACTION_FIGURE = &#39;green_action_figure&#39; . Use the FactoryProducer to get AbstractFactory in order to get factories of concrete classes by passing an information such as type . class ColorfulToysProducer: __colorful_toys_factory = ColorfulToysFactory() @classmethod def get_toy_and_color(cls, choice): toy = None color = None if choice == RED_CAR: toy = cls.__colorful_toys_factory.get_toy(&#39;car&#39;) color = cls.__colorful_toys_factory.get_color(&#39;red&#39;) elif choice == BLUE_LEGO: toy = cls.__colorful_toys_factory.get_toy(&#39;construction toy&#39;) color = cls.__colorful_toys_factory.get_color(&#39;blue&#39;) elif choice == GREEN_ACTION_FIGURE: toy = cls.__colorful_toys_factory.get_toy(&#39;action figure&#39;) color = cls.__colorful_toys_factory.get_color(&#39;green&#39;) return toy, color . toy, color = ColorfulToysProducer.get_toy_and_color(RED_CAR) toy, color . (&lt;__main__.Car at 0x253feb8a748&gt;, &lt;__main__.Red at 0x253ff224fc8&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(BLUE_LEGO) toy, color . (&lt;__main__.ConstructionToy at 0x253feb611c8&gt;, &lt;__main__.Blue at 0x253feb61548&gt;) . toy, color = ColorfulToysProducer.get_toy_and_color(GREEN_ACTION_FIGURE) toy, color . (&lt;__main__.ActionFigure at 0x253ff09f208&gt;, &lt;__main__.Green at 0x253ff09f3c8&gt;) . # Separate the construction of an object from representation # allow same construction process for many representations # parse a complex representation, create different objects # Consider a SQL query builder class # allows step-by-step creation of a SQL query # Query is a complex entity with many different parts # Applications might build once, run multiple times # Separates object construction from its representation # parse a complex construction process into simple constituent operations . class Mobile: def __init__(self, name, weight, screen_size, ram, os, camera_mp, battery): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(name=&quot;Samsung S10&quot;, weight = &quot;157g&quot;, screen_size = &quot;6.1 inch&quot;, ram = &quot;8GB&quot;, os = &quot;android 9.0&quot;, camera_mp = &quot;12 megapixel&quot;, battery = &quot;3400 mAh&quot;) . samsung_s10.show() . name: Samsung S10 weight: 157g screen_size: 6.1 inch ram: 8GB os: android 9.0 camera_mp: 12 megapixel battery: 3400 mAh . to get rid of the long list of parameters we can have the features in the main program but directly setting attributes in the client program is wrong, it goes against encapsulate what varies principle . this is prone to errors and maintenance unfriendly . class Mobile(): def __init__(self): self.name = None self.weight = None self.screen_size = None self.ram = None self.os = None self.camera_mp = None self.battery = None def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . s10 = Mobile() . s10.name = &quot;Samsung S10&quot; s10.screen_size = &quot;6.1 inch&quot;, s10.os = &quot;android 9.0&quot;, s10.camera_mp = &quot;12 megapixel&quot;, s10.battery = &quot;3400 mAh&quot; . s10.show() . name: Samsung S10 weight: None screen_size: (&#39;6.1 inch&#39;,) ram: None os: (&#39;android 9.0&#39;,) camera_mp: (&#39;12 megapixel&#39;,) battery: 3400 mAh . now the features have been encapsulated in a seperate class called MyMobile the build method instantiates a new mobile object and encapsulates setting of sttributes | . class MyMobileBuilder(): def __init__(self): self.__mobile = Mobile() def get_mobile(self): return self.__mobile def build_name(self, name): self.__mobile.name = name def build_memory(self, ram): self.__mobile.ram = ram def build_camera(self, camera_mp): self.__mobile.camera_mp = camera_mp def build_otherfeatures(self, weight, screen_size, os, battery): self.__mobile.weight = weight self.__mobile.screen_size = screen_size self.__mobile.os = os self.__mobile.battery = battery . build the mobile, get the finished product and show the features . we solved - . long parameter list problem | encapsulating attributes | . builder = MyMobileBuilder() . builder.build_name(&#39;Samsung S10&#39;) builder.build_memory(&#39;8GB&#39;) builder.build_camera(&#39;16 megapixels&#39;) . mobile = builder.get_mobile() . mobile.show() . name: Samsung S10 weight: None screen_size: None ram: 8GB os: None camera_mp: 16 megapixels battery: None . class Mobile: def __init__(self, name, weight=&#39;157gm&#39;, screen_size=&#39;5inches&#39;, ram=&#39;8GB&#39;, os=&#39;Android&#39;, camera_mp=&#39;16 megapixels&#39;, battery=&#39;3400 mAh&#39;): self.name = name self.weight = weight self.screen_size = screen_size self.ram = ram self.os = os self.camera_mp = camera_mp self.battery = battery def show(self): print(&quot;name:&quot;, self.name) print(&quot;weight:&quot;, self.weight) print(&quot;screen_size:&quot;, self.screen_size) print(&quot;ram:&quot;, self.ram) print(&quot;os:&quot;, self.os) print(&quot;camera_mp:&quot;, self.camera_mp) print(&quot;battery:&quot;, self.battery) . samsung_s10 = Mobile(&#39;Samsung S10&#39;) samsung_s10.show() . name: Samsung S10 weight: 157gm screen_size: 5inches ram: 8GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . samsung_s8 = Mobile(&#39;Samsung S8&#39;, screen_size=&#39;4.4inches&#39;, ram=&#39;4GB&#39;) samsung_s8.show() . name: Samsung S8 weight: 157gm screen_size: 4.4inches ram: 4GB os: Android camera_mp: 16 megapixels battery: 3400 mAh . # Used when the cost of initializing objects is high # Number of objects in use at a time is low # Rate of object instantiation is high # Pools used to cache and manage objects # Avoid creating new objects, when an existing one is available # Reuse objects rather than incur the cost of creating one # common example: thread pools # some processes are embarrassingly parallel # threads are expensive to create and free up # use a thread pool -&gt; mitigates the overhead of pool creation # avoids needless re-instantiation and expensive acquisition of resources . class Connection: def __init__(self): self.__is_used = False # Imagine a very heavy-duty initialization process here # to set up the database connections and connect self.connect_to_database() def acquire(self): self.__is_used = True def release(self): self.__is_used = False def is_used(self): return self.__is_used def connect_to_database(self): pass . class ConnectionPool: def __init__(self, num_connections): self.__num_connections = num_connections self.__connections = [] for i in range(num_connections): self.__connections.append(Connection()) def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(3) . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253ff03aac8&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . conn_4 = pool.acquire() conn_4 is None . True . pool.release(conn_3) . conn_4 = pool.acquire() conn_4 . &lt;__main__.Connection at 0x253ff03a5c8&gt; . pool.release(conn_2) . conn_5 = pool.acquire() conn_5 . &lt;__main__.Connection at 0x253ff03a8c8&gt; . class ConnectionPool: __instance = None def __new__(cls, num_connections): if cls.__instance is None: print(&#39;No instance exists, creating a new one&#39;) cls.__instance = super(ConnectionPool, cls).__new__(cls) cls.__instance.__num_connections = num_connections cls.__instance.__connections = [] for i in range(num_connections): cls.__instance.__connections.append(Connection()) else: print(&#39;A previously created instance exists, returning that same one&#39;) return cls.__instance def acquire(self): for i in range(self.__num_connections): connection = self.__connections[i] if not connection.is_used(): connection.acquire() return connection return None def release(self, connection): if connection.is_used(): connection.release() . pool = ConnectionPool(2) . No instance exists, creating a new one . pool = ConnectionPool(2) . A previously created instance exists, returning that same one . conn_1 = pool.acquire() conn_1 . &lt;__main__.Connection at 0x253feeed048&gt; . conn_2 = pool.acquire() conn_2 . &lt;__main__.Connection at 0x253feeed308&gt; . conn_3 = pool.acquire() conn_3 is None . True . pool.release(conn_2) . conn_3 = pool.acquire() conn_3 . &lt;__main__.Connection at 0x253feeed308&gt; . .",
            "url": "https://elydora.github.io/DataScienceBlog/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "relUrl": "/percipio/jupyter/2020/06/28/creational-design-patterns.html",
            "date": " • Jun 28, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Classes - Introduction",
            "content": "# Classes -&gt; have State (Attributes) and Behavior (Perform Actions) . # each entity is known as an instance or object # each objects has its own independent existence . # attributes are called member variables # functions perform actions on the member variables -&gt; called member functions # no limit for vars/functions . # Class variables -&gt; associated with the class itself; shared by all objects of the class # - declared outside of any method # - referred to by class name # Instance variables -&gt; associated with objects of a class; exclusive property # - declared inside any method # - referred using the self keyword . . # tries to capture the similarities and differences in real-world entities # Portray relationships # base, parent, super class | derived, child class, subclass . # Polymorphism - the ability of an object to behave in multiple ways # Encapsulation of data # Clear modular structure for code # Provides abstractions and data encapsulation # Easy to maintain and reuse code # Model real-world entities .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Introduction.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Classes - Inheritance",
            "content": "class Shape: pass class Shape(): pass class Shape(object): pass . class Shape: def __init__(self, shape_type): self.__type = shape_type def get_type(self): return self.__type . circle = Shape(&quot;circle&quot;) type(circle) . __main__.Shape . circle.get_type() . &#39;circle&#39; . square = Shape(&quot;square&quot;) type(square) . __main__.Shape . class Shape: def __init__(self, shape_type, color=&quot;Red&quot;): # optional self.__type = shape_type self.__color = color def get_type(self): return self.__type def get_color(self): return self.__color def get_area(self): pass def get_perimeter(self): pass . circle = Shape(&quot;circle&quot;) circle.get_color() . &#39;Red&#39; . class Circle(Shape): pass . circle = Circle(&quot;circle&quot;) . type(circle) . __main__.Circle . class Circle(Shape): def __init__(self): Shape.__init__(self, &quot;circle&quot;) . class Square(Shape): def __init__(self): Shape.__init__(self, &quot;square&quot;) . circle = Circle() square = Square() circle.get_type(), square.get_type() . (&#39;circle&#39;, &#39;square&#39;) . class Circle(Shape): def __init__(self, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) . circle = Circle() circle.get_color() . &#39;green&#39; . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): Shape.__init__(self, &quot;circle&quot;, color) self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . circle = Circle(5, color=&quot;orange&quot;) circle.get_area() . 78.53981633974483 . help(Circle) . Help on class Circle in module __main__: class Circle(Shape) | Circle(radius, color=&#39;green&#39;) | | Method resolution order: | Circle | Shape | builtins.object | | Methods defined here: | | __init__(self, radius, color=&#39;green&#39;) | Initialize self. See help(type(self)) for accurate signature. | | get_area(self) | | get_perimeter(self) | | - | Methods inherited from Shape: | | get_color(self) | | get_type(self) | | - | Data descriptors inherited from Shape: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . import math class Circle(Shape): def __init__(self, radius, color=&quot;green&quot;): super().__init__(self, &quot;circle&quot;, color) # super is also possible self.__radius = radius def get_area(self): return math.pi * self.__radius * self.__radius def get_perimeter(self): return 2 * math.pi * self.__radius . issubclass(Circle, Shape) . True . class Father: pass class Mother: pass . class Child1(Father, Mother): pass . help(Child1) . Help on class Child1 in module __main__: class Child1(Father, Mother) | Method resolution order: | Child1 | Father | Mother | builtins.object | | Data descriptors inherited from Father: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) . class Father: def height(self): print(&quot;I have inherited my height from my father&quot;) class Mother: def intelligence(self): print(&quot;I have inherited my intelligence from my mother&quot;) class Child(Father, Mother): def experience(self): print(&quot;My experience are all my own&quot;) . c = Child() c.height() . I have inherited my height from my father . c.intelligence() . I have inherited my intelligence from my mother . class Hominidae(): def communication(self): print(&quot;They use auditory calls and visual cues.&quot;) def walk(self): print(&quot;They are knuckle-walkers, used to hang and swing from one tree to another.&quot;) class Human(Hominidae): def communication(self): print(&quot;They use language to communicate.&quot;) def walk(self): print(&quot;They are bipeds.&quot;) class Gorilla(Hominidae): def communication(self): print(&quot;They use twenty-five distinct vocalizations to communicate.&quot;) def walk(self): print(&quot;They are knuckle-walkers.&quot;) hominidae_1 = Hominidae() human_1 = Human() gorilla_1 = Gorilla() . hominidae_1.communication() human_1.communication() gorilla_1.communication() . They use auditory calls and visual cues. They use language to communicate. They use twenty-five distinct vocalizations to communicate. . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Inheritance.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Classes - Getting Started",
            "content": "class Student: pass . object_1 = Student() . type(object_1) . __main__.Student . object_2 = Student() . object_1 . &lt;__main__.Student at 0x288a7e26148&gt; . object_2 . &lt;__main__.Student at 0x288a88928c8&gt; . isinstance(object_1, Student) . True . object_1.name = &#39;Michel&#39; object_1.email = &#39;Michel@xyz.com&#39; . object_1.name . &#39;Michel&#39; . object_1.school . AttributeError Traceback (most recent call last) &lt;ipython-input-12-68b03d9bbaba&gt; in &lt;module&gt; -&gt; 1 object_1.school AttributeError: &#39;Student&#39; object has no attribute &#39;school&#39; . object_3 = Student() object_3.name . AttributeError Traceback (most recent call last) &lt;ipython-input-13-b5626ff88877&gt; in &lt;module&gt; 1 object_3 = Student() -&gt; 2 object_3.name AttributeError: &#39;Student&#39; object has no attribute &#39;name&#39; . class Student: name = &quot;&quot; score = 0 active = True . s1 = Student() . s1.name = &quot;John&quot; s1.score = 50 s1.name, s1.score, s1.active . (&#39;John&#39;, 50, True) . # special methods are marked with __methodname__ class Student: def __init__(self): # can be anything, but self is standard print(&#39;Initialize called!&#39;) . s1 = Student() . Initialize called! . s2 = Student() s3 = Student() . Initialize called! Initialize called! . class Student: def __init__(self, name): # can be anything, but self is standard self.name = name # self refers to the current instance self.mail = name + &quot;.&quot; + &quot;@xyz.com&quot; . s1 = Student(&quot;Felix&quot;) s1.mail . &#39;Felix.@xyz.com&#39; . del s1.mail s1.mail . AttributeError Traceback (most recent call last) &lt;ipython-input-8-0ed8e4b3810a&gt; in &lt;module&gt; 1 del s1.mail -&gt; 2 s1.mail AttributeError: &#39;Student&#39; object has no attribute &#39;mail&#39; . class Competition: # class variable raise_amount = 1.04 def __init__(self, name, prize): self.name = name self.prize = prize def raise_prize(self): self.prize = self.prize * raise_amount . debate = Competition(&#39;Debate&#39;, 500) print(debate.raise_amount) . 1.04 . Competition.raise_amount . 1.04 . debate.__dict__ . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500} . Competition.__dict__ . mappingproxy({&#39;__module__&#39;: &#39;__main__&#39;, &#39;raise_amount&#39;: 1.04, &#39;__init__&#39;: &lt;function __main__.Competition.__init__(self, name, prize)&gt;, &#39;raise_prize&#39;: &lt;function __main__.Competition.raise_prize(self)&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Competition&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Competition&#39; objects&gt;, &#39;__doc__&#39;: None}) . debate.raise_amount = 10 debate.__dict__ # new instance attribute is added . {&#39;name&#39;: &#39;Debate&#39;, &#39;prize&#39;: 500, &#39;raise_amount&#39;: 10} . class Competition: def __init__(self, name, prize): self.name = name self.prize = prize self.participants = [] . debate = Competition(&#39;Debate&#39;, 500) debate.participants . [] . Competition.participants . AttributeError Traceback (most recent call last) &lt;ipython-input-5-ea531b615844&gt; in &lt;module&gt; -&gt; 1 Competition.participants AttributeError: type object &#39;Competition&#39; has no attribute &#39;participants&#39; . debate.participants.append(&#39;Alice&#39;) . debate.participants . [&#39;Alice&#39;] . # hack for private attributes: class Dog: def __init__(self, name, breed): self.__name = name self.__breed = breed def print_details(self): print(&#39;My name is %s and I am a %s&#39; % (self.__name, self.__breed)) . d1 = Dog(&quot;Moje&quot;, &quot;Golden Retriever&quot;) d1.print_details() . My name is Moje and I am a Golden Retriever . d1.__dict__ . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;} . d1.__name = &quot;Oba&quot; d1.print_details() # doesn&#39;t update . My name is Moje and I am a Golden Retriever . d1.__dict__ # new attribute created . {&#39;_Dog__name&#39;: &#39;Moje&#39;, &#39;_Dog__breed&#39;: &#39;Golden Retriever&#39;, &#39;__name&#39;: &#39;Oba&#39;} . d1._Dog__breed = &quot;Husky&quot; # makes it harder to change, but can be changed d1.print_details() . My name is Moje and I am a Husky . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-GettingStarted.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Classes - Advanced Functionality",
            "content": "class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes rowing = Competition(&quot;Rowing&quot;, 10000) . print(rowing) . &lt;__main__.Competition object at 0x000001D68AE718C8&gt; . rowing . &lt;__main__.Competition at 0x1d68ae718c8&gt; . class Competition: def __init__(self, name, prizes): self.__name = name self.__prize = prizes def __repr__(self): # representation for print function, if __str__ is not defined return &quot;(&#39;{}&#39;, {})&quot;.format(self.__name, self.__prize) . archery = Competition(&quot;Archery&quot;, 8000) . print(archery) . (&#39;Archery&#39;, 8000) . str(archery) # looks for special method __str__() . &#34;(&#39;Archery&#39;, 8000)&#34; . repr(archery) . &#34;(&#39;Archery&#39;, 8000)&#34; . class Competition: def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) . archery = Competition(&quot;Archery&quot;, &quot;United Kingdom&quot;, 7500) archery . Competition: Archery held in United Kingdom, prize: 7500 . print(archery) . &#39;Archery United Kingdom - 7500&#39; . 1 + 2 . 3 . int.__add__(1, 2) . 3 . str.__add__(&quot;a&quot;, &quot;b&quot;) . &#39;ab&#39; . class Savings: def __init__(self, amount): self.__amount = amount . s1 = Savings(1000) s2 = Savings(22000) . s1 + s2 . TypeError Traceback (most recent call last) &lt;ipython-input-27-07ecabcb1b41&gt; in &lt;module&gt; -&gt; 1 s1 + s2 TypeError: unsupported operand type(s) for +: &#39;Savings&#39; and &#39;Savings&#39; . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount . s1 = Savings(1000) s2 = Savings(22000) s1 + s2 . 23000 . class Savings: def __init__(self, amount): self.__amount = amount def __add__(self, other): return self.__amount + other.__amount def __sub__(self, other): return self.__amount - other.__amount . s1 = Savings(5000) s2 = Savings(457) s1 - s2 . 4543 . 1.0 * 2.1 . 2.1 . float.__mul__(1.0, 2.1) . 2.1 . float.__mul__(1, 2.1) . TypeError Traceback (most recent call last) &lt;ipython-input-37-ee0b82aa5938&gt; in &lt;module&gt; -&gt; 1 float.__mul__(1, 2.1) TypeError: descriptor &#39;__mul__&#39; requires a &#39;float&#39; object but received a &#39;int&#39; . 10 // 3 . 3 . int.__floordiv__(10, 3) . 3 . int.__mod__(4, 2) . 0 . int.__mod__(10, 3) . 1 . int.__pow__(6, 2) . 36 . len(&quot;test&quot;) . 4 . str.__len__(&quot;test&quot;) . 4 . some_list = [1, 4, 5, 7, 2] len(some_list) . 5 . class Participants: def __init__(self): self.__participants = [] def add_participants(self, name): self.__participants.append(name) def __len__(self): return len(self.__participants) . participants = Participants() participants.add_participants(&quot;Felix&quot;) participants.add_participants(&quot;Johan&quot;) participants.add_participants(&quot;Max&quot;) . len(participants) . 3 . class Wrestler: def __init__(self): self.__name = &quot;&quot; def set_name(self, name): print(&quot;setter method called&quot;) self.__name = name def get_name(self): print(&quot;getter method called&quot;) return self.__name def del_name(self): del self.__name name = property(get_name, set_name, del_name) . w = Wrestler() . w.name = &quot;Kart&quot; . setter method called . w.name . getter method called . &#39;Kart&#39; . class WrestlerNew: def __init__(self, name): self.__name = name @property # this is the method for accessing def name(self): print(&quot;getter method called&quot;) return self.__name @name.setter # this is the method for setting new vals def name(self, value): print(&quot;setter method called&quot;) self.__name = value @name.deleter def name(self): del self.__name . w1 = WrestlerNew(&quot;Rey&quot;) . w1.name . getter method called . &#39;Rey&#39; . class Competition: __raise_amount = 1.04 # class variable def __init__(self, name, country, prize): self.__name = name self.__country = country self.__prize = prize def raise_prize(self): self.__prize = self.__prize * self.__raise_amount def get_name_country(self): return &#39;{} {}&#39;.format(self.__name, self.__country, self.__prize) def __repr__(self): # representation for print function return &quot;Competition: {} held in {}, prize: {}&quot;.format(self.__name, self.__country, self.__prize) def __str__(self): return &quot;&#39;{} - {}&#39;&quot;.format(self.get_name_country(), self.__prize) @classmethod def get_raise_amount(cls): return cls.__raise_amount @classmethod def set_raise_amount(cls, amount): cls.__raise_amount = amount . c1 = Competition(&quot;Running&quot;, &quot;Germany&quot;, 50000) . c1.set_raise_amount(2) . c1.get_raise_amount() . 2 . Competition.get_raise_amount() . 2 . class Rectangle: @staticmethod # cannot access class variables def area(x,y): return x * y . Rectangle.area(5,5) . 25 . from abc import ABC, abstractmethod class Hominidae(): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . chimpanzee = Hominidae() chimpanzee.behavior() . Blabla . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . paul = Human() paul.diet() . Omnivorous . class Hominidae(ABC): def diet(self): pass def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h = Hominidae() . h.behavior() . Blabla . h.diet() . class Human(Hominidae): def diet(self): print(&quot;Omnivorous&quot;) def walk(self): print(&quot;Bipeds&quot;) . myra = Human() myra.diet() myra.walk() . Omnivorous Bipeds . class Hominidae(ABC): @abstractmethod # how to do it def diet(self): pass @abstractmethod def walk(self): pass def behavior(self): print(&quot;Blabla&quot;) . h1 = Hominidae() . TypeError Traceback (most recent call last) &lt;ipython-input-131-df612faa022d&gt; in &lt;module&gt; -&gt; 1 h1 = Hominidae() TypeError: Can&#39;t instantiate abstract class Hominidae with abstract methods diet, walk . .",
            "url": "https://elydora.github.io/DataScienceBlog/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "relUrl": "/classes/jupyter/percipio/2020/06/23/classes-Advanced-Functionality.html",
            "date": " • Jun 23, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Implementing Data Structures",
            "content": "def addition(num1, num2): total = num1 + num2 print(&quot;The sum of %d and %d is %d&quot; %(num1, num2, total)) . addition(10, 4) . The sum of 10 and 4 is 14 . def addition(num1, num2): num_iterations = 0 total = num1 + num2 num_iterations += 1 print(&quot;The sum of %d and %d is %d n total number: %d&quot; %(num1, num2, total, num_iterations)) . addition(50,10) # O(1) operation, number of operations is constant, no matter the input . The sum of 50 and 10 is 60 total number: 1 . def check_prime1(number): num_iterations = 0 for i in range(2, number): num_iterations += 1 if number%i == 0: print(&quot;%d is not a prime number n Total number of iterations = %d&quot; %(number, num_iterations)) return print(&quot;%d is a prime number nTotal number of iterations = %d&quot; %(number, num_iterations)) . check_prime1(10) . 10 is not a prime number Total number of iterations = 1 . check_prime1(50) . 50 is not a prime number Total number of iterations = 1 . check_prime1(1) . 1 is a prime number Total number of iterations = 0 . check_prime1(49) . 49 is not a prime number Total number of iterations = 6 . check_prime1(191) . 191 is a prime number Total number of iterations = 189 . # that takes longer, if the input list gets longer . def print_pairs(number_list): num_iterations = 0 n = len(number_list) for i in range(n): for j in range(n): print(number_list[i], number_list[j]) num_iterations += 1 print(&quot;Total iterations are %d&quot; % num_iterations) . print_pairs([123,67]) . 123 123 123 67 67 123 67 67 Total iterations are 4 . print_pairs([123,67, 25, 79]) . 123 123 123 67 123 25 123 79 67 123 67 67 67 25 67 79 25 123 25 67 25 25 25 79 79 123 79 67 79 25 79 79 Total iterations are 16 . . from queue import Queue olympics = Queue(5) olympics . &lt;queue.Queue at 0x2e919de0708&gt; . olympics.put(&quot;United Statues(USA)&quot;) olympics.put(&quot;Great Britain(GBR)&quot;) . olympics.empty() # O(1) . False . olympics.full() # O(1) . False . olympics.qsize() # O(1) . 2 . olympics.put(&quot;China(CHN)&quot;) olympics.put(&quot;Russia(RUS)&quot;) olympics.put(&quot;Germany(GER)&quot;) . olympics.full() . True . olympics.qsize() . 5 . olympics.get() . &#39;United Statues(USA)&#39; . olympics.qsize() . 4 . olympics.full() . False . stack = [] stack.append(&quot;United States&quot;) stack.append(&quot;Great Britain&quot;) stack.append(&quot;China&quot;) . stack . [&#39;United States&#39;, &#39;Great Britain&#39;, &#39;China&#39;] . stack.pop() . &#39;China&#39; . class Node: def __init__(self, dataval=None, nextval=None): self.dataval = dataval self.nextval = nextval def __repr__(self): return repr(self.dataval) class LinkedList: def __init__(self): self.head = None def __repr__(self): # O(N) nodes = [] curr = self.head while curr: nodes.append(repr(curr)) curr = curr.nextval return &quot;[&quot; + &quot;-&gt;&quot;.join(nodes) + &quot;]&quot; def prepend(self, dataval): # O(1) self.head = Node(dataval=dataval, nextval = self.head) def append(self, dataval): if not self.head: self.head = Node(dataval=dataval) return curr = self.head while curr.nextval: curr = curr.nextval curr.nextval = Node(dataval=dataval) def add_after(self, middle_dataval, dataval): if middle_dataval is None: print(&quot;Data to insert after not specified&quot;) return curr = self.head while curr and curr.dataval != middle_dataval: curr = curr.nextval new_node = Node(dataval = dataval) new_node.nextval = curr.nextval curr.nextval = new_node def find(self, data): curr = self.head while curr and curr.dataval != data: curr = curr.nextval return curr def remove(self, data): curr = self.head prev = None while curr and curr.dataval != data: prev = curr curr = curr.nextval if prev is None: self.head = curr.nextval elif curr: prev.nextval = curr.nextval curr.nextval = None def reverse(self): curr = self.head prev_node = None next_node = None while curr: nextval = curr.nextval curr.nextval = prev_node prev_node = curr curr = nextval self.head = prev_node . numbers = LinkedList() . numbers . [] . numbers.append(&quot;two&quot;) numbers.append(&quot;three&quot;) numbers . [&#39;two&#39;-&gt;&#39;three&#39;] . numbers.prepend(&quot;one&quot;) numbers . [&#39;one&#39;-&gt;&#39;two&#39;-&gt;&#39;three&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Implementing-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Fundamental Data Structures",
            "content": "# make difficult operations possible # occupy less space and still represent the complexity of information and # its interrelationships in an intuitive way # data structures and algorithms go hand-in-hand # A set is extremely fast for membership and containment queries # stacks can be used for undo functionality in applications as well as back functionality # index data structures # hash tables # graphs for relationships # data structures are concrete representations of data from the point of view of an implementor # they specify the actual implementation of the structure in code to meet the expected behavior . Hallo . # Time (# of operations / amount of processing) # Space (make best use of available space, memory and disk space needed) # Network (overall network bandwidth, network speed) # efficient = uses fewer resources along all these axes # using more of the resources that are plenty, and less of those who lack # performance indicates how much of these resources are used by the code # == Performance can be measured in terms of complexity # Complexity is a measure of how resource requirements change as the size of the problem gets larger # The higher the complexity of a overall problem, the lower the performance . 2 . # Read - Write - Assignment - Test # do not worry about the number of operations # be worried how that number changes is based on the input size # that is how performance changes based on input size # focus on the worst case performance # what is the maximum number of basic operations that might have to be performed based on the input # Complexity varies with the algorithm . # Represents the complexity of an algorithm # An algorithm whose complexity does not change with the input size is O(1) # -&gt; the algorithm is said to have constant time complexity # The algorithm is said to have constant time complexity # It takes the same amount of time, even if the input size is doubled, tripled, or increased to any level . # The complexity of an algorithm is O(N^2) if the time taken by the algorithm increases quadratically when N increases # Lower order terms and constants do not matter while expressing complexity # O(N^2 + 1000) is equivalent to O(N^2) -&gt; N is assumed very large # O(N^2+N) is equivalent to O(N^2) . . # Header points to the first element # Best way to count is to increment/decrement a counter at every list operation # Adding: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Deleting: At the end/ in between -&gt; O(N); at the beginning -&gt; O(1) # Counting: Iterating -&gt; O(1), Increment/Decrement a permanent Counter -&gt; O(1) # Reversing: O(N) . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # LIFO principle # Insertion and deletion at the same end . # Common operations (add, remove, peek) have O(1) complexity # Can be implemented using a linked list # FIFO principle # Insertion and deletion at opposite ends . .",
            "url": "https://elydora.github.io/DataScienceBlog/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "relUrl": "/datastructures/jupyter/percipio/2020/06/22/Fundamental-Data-Structures.html",
            "date": " • Jun 22, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Complex Data Types - Lists and Tuples",
            "content": "empty_list = [] empty_list . list_str=[&quot;Toyota&quot;,&quot;VW&quot;,&quot;BMW&quot;,&quot;Mercedes&quot;] list_str . list_bool=[True, False, False, True] list_bool . list_str[1] . list_str[len(list_str)-1] . list_str[-1] . list_str[0] = &quot;Hyundai&quot; list_str . list_str.append(&quot;Opel&quot;) list_str . list_str += [&#39;Dacia&#39;, &#39;Ford&#39;] list_str . list_str.sort() list_str . list_str.reverse() list_str . list_str.pop() list_str . list_str.count(&quot;Dacia&quot;) . print(list_str) . new_list = list_str.copy() list_str.clear() list_str . del list_str . list_2 = sorted(new_list) # whole new list . any([0]) # greater 0 . any([0, 1]) . all([0,1]) . new_list[0:2] # creates a deep copy . new_list[0:100] . new_list[1:] . new_list[:3] . new_list[:-1] . new_list[-4:-1] . new_list[0:5:2] . &quot;Dacia&quot; in new_list . new_list[::-3] . new_list[100] . new_list.count() .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-ListsAndTuples.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Complex Data Types - Dictionaries and Sets",
            "content": "empty_dict = {} empty_dict . {} . bike_owners = {&quot;James&quot;:&quot;Ducati Monster 1200&quot;, &quot;Jacob&quot;:&quot;Ducati Scrambler 1100&quot;} bike_owners . {&#39;James&#39;: &#39;Ducati Monster 1200&#39;, &#39;Jacob&#39;: &#39;Ducati Scrambler 1100&#39;} . bike_owners[&quot;Jacob&quot;] . &#39;Ducati Scrambler 1100&#39; . int_dict = {1:45, 2:55, 3:65} int_dict[1] . 45 . int_dict.keys() . dict_keys([1, 2, 3]) . 1 in int_dict.keys() . True . mixed_dict = {False: &quot;Daniel&quot;, &quot;Aria&quot;:[1,2,3], &quot;Jacob&quot;:True} mixed_dict . {False: &#39;Daniel&#39;, &#39;Aria&#39;: [1, 2, 3], &#39;Jacob&#39;: True} . mixed_dict[False] . &#39;Daniel&#39; . int_dict[1] = 78 int_dict . {1: 78, 2: 55, 3: 65} . del int_dict[3] int_dict . {1: 78, 2: 55} . fruits = { &quot;Banana&quot;:[50,60,75,99], &quot;Apple&quot;:[48,86,47,25], &quot;Strawberries&quot;:[70,80,60,65] } print(fruits[&quot;Banana&quot;]) print(fruits[&quot;Banana&quot;][3]) fruits[&quot;Banana&quot;][3]=50 print(fruits[&quot;Banana&quot;][3]) . [50, 60, 75, 99] 99 50 . fruit_qtc_consumed = { &quot;Banana&quot;: {&quot;Fri&quot;:90, &quot;Mo&quot;:80, &quot;Di&quot;:90}, &quot;Apple&quot;:{&quot;Fri&quot;:10, &quot;Mo&quot;:12, &quot;Di&quot;:13}, &quot;Strawberry&quot;:{&quot;Fri&quot;:47, &quot;Mo&quot;:48, &quot;Di&quot;:20}, } print(fruit_qtc_consumed[&quot;Strawberry&quot;]) print(fruit_qtc_consumed[&quot;Strawberry&quot;][&quot;Fri&quot;]) . {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20} 47 . len(fruit_qtc_consumed) . 3 . len(fruit_qtc_consumed.keys()) . 3 . sorted(fruit_qtc_consumed) . [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Strawberry&#39;] . sorted(fruit_qtc_consumed, reverse=True) . [&#39;Strawberry&#39;, &#39;Banana&#39;, &#39;Apple&#39;] . fruit_qtc_consumed.items() . dict_items([(&#39;Banana&#39;, {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}), (&#39;Apple&#39;, {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}), (&#39;Strawberry&#39;, {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20})]) . copy = fruit_qtc_consumed.copy() copy . {&#39;Banana&#39;: {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90}, &#39;Apple&#39;: {&#39;Fri&#39;: 10, &#39;Mo&#39;: 12, &#39;Di&#39;: 13}, &#39;Strawberry&#39;: {&#39;Fri&#39;: 47, &#39;Mo&#39;: 48, &#39;Di&#39;: 20}} . copy.pop(&quot;Banana&quot;) . {&#39;Fri&#39;: 90, &#39;Mo&#39;: 80, &#39;Di&#39;: 90} . persons1 = {&quot;Ethan&quot;:45,&quot;Monica&quot;:88,&quot;Max&quot;:10} persons2 = {&quot;Ethan&quot;:46,&quot;Claus&quot;:47,&quot;Rainer&quot;:44} print(persons1) persons1.update(persons2) print(persons1) . {&#39;Ethan&#39;: 45, &#39;Monica&#39;: 88, &#39;Max&#39;: 10} {&#39;Ethan&#39;: 46, &#39;Monica&#39;: 88, &#39;Max&#39;: 10, &#39;Claus&#39;: 47, &#39;Rainer&#39;: 44} . persons2.clear() persons2 . {} . del persons2 . set_string = {&quot;Emma&quot;, &quot;Olivia&quot;, &quot;Ava&quot;, &quot;Mia&quot;} set_string . {&#39;Ava&#39;, &#39;Emma&#39;, &#39;Mia&#39;, &#39;Olivia&#39;} . print(set_string) # no intrinsic ordering . {&#39;Ava&#39;, &#39;Mia&#39;, &#39;Emma&#39;, &#39;Olivia&#39;} . empty_set = set() . mixed_set = {&quot;Emmma&quot;, 5, 1.5, True,(1,2,3,4)} #Lists are not allowed . student_set = {&quot;Emma&quot;, &quot;Marc&quot;, &quot;Janine&quot;, &quot;Emma&quot;} student_set # duplicates are eliminated . {&#39;Emma&#39;, &#39;Janine&#39;, &#39;Marc&#39;} . student_set[1] . TypeError Traceback (most recent call last) &lt;ipython-input-35-a8e02497ae7e&gt; in &lt;module&gt; -&gt; 1 student_set[1] 2 3 TypeError: &#39;set&#39; object is not subscriptable . student_set.add(&quot;Felix&quot;) . len(student_set) . 4 . max(student_set) . &#39;Marc&#39; . student_set.remove(&quot;Felix&quot;) student_set.discard(&quot;Felix&quot;) . number1={1,2,3,4,5} number2={4,5,6,7,8} number3={7,8,9,10,11} . number1.union(number2) . {1, 2, 3, 4, 5, 6, 7, 8} . number1.difference(number2) . {1, 2, 3} . number1.isdisjoint(number2) . False . number1.isdisjoint(number3) . True . car_matrix = [[&quot;Hennessey Venom GT&quot;, 1244], [&quot;SSC Ultimate Aero&quot;, 1287], [&quot;Zenvo ST1&quot;, 1100]] car_matrix . [[&#39;Hennessey Venom GT&#39;, 1244], [&#39;SSC Ultimate Aero&#39;, 1287], [&#39;Zenvo ST1&#39;, 1100]] . len(car_matrix) . 3 . len(car_matrix[1]) . 2 . car_matrix[1][0] . &#39;SSC Ultimate Aero&#39; . car_matrix[1] . [&#39;SSC Ultimate Aero&#39;, 1287] . car_matrix[1][0:2] . [&#39;SSC Ultimate Aero&#39;, 1287] . my_list = [&quot;Leo&quot;,18,&quot;Aaron&quot;,15,&quot;Max&quot;,25,&quot;Sofi&quot;,22,&quot;Marques&quot;,2,&quot;Julia&quot;,91,] print(my_list) print(tuple(my_list)) # tuple is immutable . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] (&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91) . my_list1 = [[&quot;Leo&quot;,18],[&quot;Aaron&quot;,48],[&quot;Max&quot;,25],[&quot;Sofi&quot;,22],[&quot;Marques&quot;,2],[&quot;Julia&quot;,91]] tuple(my_list1) . ([&#39;Leo&#39;, 18], [&#39;Aaron&#39;, 48], [&#39;Max&#39;, 25], [&#39;Sofi&#39;, 22], [&#39;Marques&#39;, 2], [&#39;Julia&#39;, 91]) . d_list = dict(my_list1) names = list(d_list) names . [&#39;Leo&#39;, 18, &#39;Aaron&#39;, 15, &#39;Max&#39;, 25, &#39;Sofi&#39;, 22, &#39;Marques&#39;, 2, &#39;Julia&#39;, 91] . d_list2 = dict(my_list1) names2 = list(d_list2.values()) names2 . [18, 48, 25, 22, 2, 91] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DictionaryAndSetsInPython.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Complex Data Types - Deep and Shallow Copies",
            "content": "old_str = &quot;Python&quot; old_str . &#39;Python&#39; . new_str = old_str print(old_str) print(new_str) . Python Python . new_str[2] = &quot;T&quot; . TypeError Traceback (most recent call last) &lt;ipython-input-3-b6e8ff6bdf2e&gt; in &lt;module&gt; -&gt; 1 new_str[2] = &#34;T&#34; TypeError: &#39;str&#39; object does not support item assignment . import copy . first_str = &quot;Will&quot; second_str = copy.copy(first_str) print(first_str) print(second_str) . Will Will . second_str = &quot;Smith&quot; print(first_str) print(second_str) . Will Smith . first_str = &quot;Johnny&quot; second_str = copy.deepcopy(first_str) # the same print(first_str) print(second_str) . Johnny Johnny . second_str = &quot;Depp&quot; print(first_str) print(second_str) . Johnny Depp . names = [&quot;Jan&quot;, &quot;Felix&quot;, &quot;Ralph&quot;] second_names = names . second_names[1] = &quot;Maria&quot; print(names) print(second_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . third_names = copy.copy(names) third_names[0] = &quot;Julia&quot; print(names) print(third_names) . [&#39;Jan&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] [&#39;Julia&#39;, &#39;Maria&#39;, &#39;Ralph&#39;] . .",
            "url": "https://elydora.github.io/DataScienceBlog/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "relUrl": "/datatypes/jupyter/percipio/2020/06/21/comp-dt-DeepAndShallowCopies.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Functions - General",
            "content": "country = &quot;USA&quot; def some_fn(): print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): country = &quot;India&quot; print(&quot;Country: &quot;, country) . some_fn() . def some_fn(): global country country = &quot;Bangladesh&quot; print(country) some_fn() . country . fruits_list = [&quot;Apple&quot;, &quot;Grapes&quot;, &quot;Mango&quot;, &quot;Bananas&quot;] def change_list(fruits_list): fruits_list[0] = &quot;Kiwi&quot; fruits_list = [&quot;Kiwi&quot;] # does nothing on the outside print(&quot;Inside the function: &quot;, fruits_list) change_list(fruits_list) print() print(&quot;Outside the function: &quot;, fruits_list) . help(&quot;modules&quot;) . import math . print(math.pi) . math.e . math.ceil(8.1) . math.floor(8.1) . math.pow(2,4) . math.sqrt(24) . import os . os.getcwd() . os.environ . user = os.environ[&quot;USERNAME&quot;] user . os.environ[&quot;PATH&quot;] . os.listdir() . os.listdir(&quot;.&quot;) . os.path.isdir(os.environ[&quot;PATH&quot;]) . os.path.isfile(os.environ[&quot;PATH&quot;]) . import random . random.random() . random.random() . random.randint(0, 10) . listA = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] random.choice(listA) . import datetime datetime.date.today() . datetime.datetime.now() . def hello(name): print(&quot;Hello!&quot;, name) hello(&quot;Bruce&quot;) . hello . greet = hello . greet(&quot;Max&quot;) . calculate_length = len calculate_length(&quot;SomeString&quot;) . calculate_length == len . import math def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) def diameter_circle_fn(r): pass calculate(10, fn=diameter_circle_fn) . def area_rectangle_fn(length, breadth): return length * breadth def calculate(*args, fn): # * -&gt; multiple arguments, unpack the args tuple return fn(*args) calculate(20, 40, fn=area_rectangle_fn) . def square(x): return x * x . result = square(5) result . square . sq = square . result = sq(12) result . cube_of = lambda x: x * x * x result = cube_of(3) result . cube_of . add = lambda x, y: x + y . result = add(5, 10) result . (lambda x: x + 2)(10) . (lambda x:x * 10)(22) . def check_if_even(x): assert x % 2 == 0 . check_if_even(2) . check_if_even(3) . even_check_lambda = lambda x : assert x % 2 == 0 . total_score = lambda math, physics, chemistry, biology=50: math+physics+chemistry+biology . total_score(math=50, physics=10, chemistry=23) . (lambda **num_dictionary: sum(num_dictionary.values()))(a=23, b=34, c=45) . num_list = [1,5,6,7,11,78,99,34,105,214] . filter(lambda x: x &gt; 10, num_list) . greater_than_10_list = list(filter(lambda x: x &gt; 10, num_list)) greater_than_10_list . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-general.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Functions - Advanced",
            "content": "def hello(name): print(&quot;Hello&quot;, name) hello(name) #hello(&quot;Ron&quot;) . import sys sys.getrecursionlimit() . 3000 . def increment(num): print(num, end = &quot; &quot;) increment(num + 1) return #increment(1) . def decrement(num): while num &gt; 0: print(num) num = num - 1 decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def decrement(num): if num == 0: return print(num) decrement(num - 1) decrement(10) . 10 9 8 7 6 5 4 3 2 1 . def generator(): print(&quot;One!&quot;) yield 1 # control execution flow print(&quot;Two!&quot;) yield 2 print(&quot;Three!&quot;) yield 3 g = generator() # no code execution g . &lt;generator object generator at 0x000001A6BE9FBCC8&gt; . next(g) # execute g until the first yield statement . One! . 1 . next(g) # second yield statement . Two! . 2 . next(g) # until third statement . Three! . 3 . next(g) . StopIteration Traceback (most recent call last) &lt;ipython-input-20-e734f8aca5ac&gt; in &lt;module&gt; -&gt; 1 next(g) StopIteration: . g2 = generator() g . next(g2) . def generator(): print(&quot;One!&quot;) n = 1 yield n # control execution flow print(&quot;Two!&quot;) n += 1 yield n print(&quot;Three!&quot;) n += 1 yield n g3 = generator() . next(g3) . next(g3) . def generate_even_numbers(limit): for i in range(0, limit, 2): yield i . g = generate_even_numbers(7) . next(g) . next(g) . next(g) . next(g) . next(g) . g2 = generate_even_numbers(20) g2_list = list(g2) . g2_list . def generate_powers_of_two(): num = 0 while True: num = num + 1 yield 2 ** num . g = generate_powers_of_two() . next(g) . next(g) . def nested_hello_fn(): def hello(): print(&quot;Hello Cathy!&quot;) hello() . nested_hello_fn() . hello() . def get_hello_fn(): # every closure has its own local state (do not share local variables) def hello(): print(&quot;Hello Cathy!&quot;) return hello . hello_fn = get_hello_fn() . hello_fn() . def print_message(): print(&quot;Yohoo! Decorators are cool!&quot;) . print_message() . import random def highlight(): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) print_message() print(annotate * 50) highlight() . def make_highlighted(func): annotations = [&quot;-&quot;, &quot;*&quot;, &quot;+&quot;] annotate = random.choice(annotations) print(annotate * 50) func() print(annotate * 50) make_highlighted(print_message) . @make_highlighted # that&#39;S how they are really used def print_a_message(): print(&quot;Now you&#39;ll see how decorators are used&quot;) print_a_message . def plus_highlight(func): def highlight(): print(&quot;+&quot;*50) func() print(&quot;+&quot;*50) return highlight def asterisk_highlight(func): def highlight(): print(&quot;*&quot;*50) func() print(&quot;*&quot;*50) return highlight @plus_highlight @asterisk_highlight def hello(): print(&quot;hello!&quot;) hello() . .",
            "url": "https://elydora.github.io/DataScienceBlog/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "relUrl": "/functions/jupyter/percipio/2020/06/20/functions-advanced.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Introducing fastpages",
            "content": ". We are very pleased to announce the immediate availability of fastpages. fastpages is a platform which allows you to create and host a blog for free, with no ads and many useful features, such as: . Create posts containing code, outputs of code (which can be interactive), formatted text, etc directly from Jupyter Notebooks; for instance see this great example post from Scott Hawley. Notebook posts support features such as: Interactive visualizations made with Altair remain interactive. | Hide or show cell input and output. | Collapsable code cells that are either open or closed by default. | Define the Title, Summary and other metadata via a special markdown cells | Ability to add links to Colab and GitHub automatically. | . | Create posts, including formatting and images, directly from Microsoft Word documents. | Create and edit Markdown posts entirely online using GitHub&#39;s built-in markdown editor. | Embed Twitter cards and YouTube videos. | Categorization of blog posts by user-supplied tags for discoverability. | ... and much more | . fastpages relies on Github pages for hosting, and Github Actions to automate the creation of your blog. The setup takes around three minutes, and does not require any technical knowledge or expertise. Due to built-in automation of fastpages, you don&#39;t have to fuss with conversion scripts. All you have to do is save your Jupyter notebook, Word document or markdown file into a specified directory and the rest happens automatically. Infact, this blog post is written in a Jupyter notebook, which you can see with the &quot;View on GitHub&quot; link above. . fast.ai have previously released a similar project called fast_template, which is even easier to set up, but does not support automatic creation of posts from Microsoft Word or Jupyter notebooks, including many of the features outlined above. . Because fastpages is more flexible and extensible, we recommend using it where possible. fast_template may be a better option for getting folks blogging who have no technical expertise at all, and will only be creating posts using Github&#39;s integrated online editor. . Setting Up Fastpages . The setup process of fastpages is automated with GitHub Actions, too! Upon creating a repo from the fastpages template, a pull request will automatically be opened (after ~ 30 seconds) configuring your blog so it can start working. The automated pull request will greet you with instructions like this: . . All you have to do is follow these instructions (in the PR you receive) and your new blogging site will be up and running! . Jupyter Notebooks &amp; Fastpages . In this post, we will cover special features that fastpages provides for Jupyter notebooks. You can also write your blog posts with Word documents or markdown in fastpages, which contain many, but not all the same features. . Options via FrontMatter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . All of the above settings are enabled in this post, so you can see what they look like! . the summary field (preceeded by &gt;) will be displayed under your title, and will also be used by social media to display as the description of your page. | toc: setting this to true will automatically generate a table of contents | badges: setting this to true will display Google Colab and GitHub links on your blog post. | comments: setting this to true will enable comments. See these instructions for more details. | author this will display the authors names. | categories will allow your post to be categorized on a &quot;Tags&quot; page, where readers can browse your post by categories. | . Markdown front matter is formatted similarly to notebooks. The differences between the two can be viewed on the fastpages README. . Code Folding . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . If you want to completely hide cells (not just collapse them), read these instructions. . Interactive Charts With Altair . Interactive visualizations made with Altair remain interactive! . We leave this below cell unhidden so you can enjoy a preview of syntax highlighting in fastpages, which uses the Dracula theme. . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;IMDB_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget IMDB_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | 6.1 | . 1 First Love, Last Rites | 10876.0 | 300000.0 | 6.9 | . 2 I Married a Strange Person | 203134.0 | 250000.0 | 6.8 | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | NaN | . 4 Slam | 1087521.0 | 1000000.0 | 3.4 | . Other Features . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Images w/Captions . You can include markdown images with captions like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Of course, the caption is optional. . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . More Examples . This tutorial contains more examples of what you can do with notebooks. . How fastpages Converts Notebooks to Blog Posts . fastpages uses nbdev to power the conversion process of Jupyter Notebooks to blog posts. When you save a notebook into the /_notebooks folder of your repository, GitHub Actions applies nbdev against those notebooks automatically. The same process occurs when you save Word documents or markdown files into the _word or _posts directory, respectively. . We will discuss how GitHub Actions work in a follow up blog post. . Resources &amp; Next Steps . We highly encourage you to start blogging with fastpages! Some resources that may be helpful: . fastpages repo - this is where you can go to create your own fastpages blog! | Fastai forums - nbdev &amp; blogging category. You can ask questions about fastpages here, as well as suggest new features. | nbdev: this project powers the conversion of Jupyter notebooks to blog posts. | . If you end up writing a blog post using fastpages, please let us know on Twitter: @jeremyphoward, @HamelHusain. .",
            "url": "https://elydora.github.io/DataScienceBlog/fastpages/jupyter/2020/02/21/ref-intro.html",
            "relUrl": "/fastpages/jupyter/2020/02/21/ref-intro.html",
            "date": " • Feb 21, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://elydora.github.io/DataScienceBlog/jupyter/2020/02/20/ref-notebooks.html",
            "relUrl": "/jupyter/2020/02/20/ref-notebooks.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://elydora.github.io/DataScienceBlog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "SAP developer by day, Python developer by night. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://elydora.github.io/DataScienceBlog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://elydora.github.io/DataScienceBlog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}